---
title: 软考中级软件设计师案例试题
date: 2025-05-19T11:32:25+08:00
categories: 软考 
tags: 软考
description: 
keywords: 
---

## 2023年下半年案例试题

## 2023年上半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
随着农业领域科学种植的发展，需要对农业基地及农事进行的信息化管理，为租户和农户等人员提供种植相关服务。现欲开发农事管理服务平台。其主要功能是：
（1）人员管理。平台管理员管理租户；租户管理农户并为其分配负责的地块，租户和农户以人员类型区分。
（2）基地管理。租户填写基地名称、地域等描述信息...在显示的地图上绘制地块。
（3）种植管理。租户设定作物及其从种植到采收的整个农事过程，包括农事活动及其实施计划，农户根据相应农事过程提醒进行农事活动并记录。系统会在设定时间向农户进行农事提醒，对逾期未实施活动向租户发出逾期告警。
（4）投入品管理。租户统—维护化肥，杀虫剂等投入品信息.农户在农事活动中设定投入品的实际消耗。
（5）信息服务。用户按查询条件发起农事信息请求，对相关地块农事活动实施情况（如与农事过程比对）等农事信息进行筛选、对比和统计等处理，并将响应信息进行展示。系统也给其他第三方软件提供APP接口，通过接口访问的方式，提供账号、密码和查询条件发起农事信息请求，返回特定格式的农事信息，无查询条件时默返回账号下所有信息，多查询条件时返回满足全部条件的信息。
现采用结构化方法对农事管理服务平台进行分析与设计，获得如图所示的上下文数据流图和图2所示的0层数据流图。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-1-1.png)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-1-2.png)

【问题1】（4分）使用说明中的词语，给出图1中的突体E1～E4的名称。

- **E1：平台管路员**；
  **E2：农户**；
  **E3：租户**；
  **E4：用户**。

【问题2】（4分）使用说明中的词活，给出图2中数据存储D1～D4的名称。

- **D1：用户**；
  **D2：基地/地块**；
  **D3：农事过程**；
  **D4：弄事活动**。

【问题3】（4分）根据说明和图中术语，补充2中缺失的数据流及其起点和终点。

- |     数据流     | 起点 | 终点 |
  | :------------: | :--: | :--: |
  | 投入品实际消耗 |  E2  |  P4  |
  |   投入品信息   |  P4  |  E2  |
  |    基地信息    |  P2  |  E2  |
  |    农事过程    |  P3  |  E2  |

【问题4】（3分）根据说明，给出“农事信息请求”数据流的组成。

- 根据“对相关地块农事活动实施情况（如与农事过程比对）等农事信息进行筛选、对比和统计等处理...”，可知“农事信息请求”数据流包括：**农事活动信息**、**农事过程信息**、**地块信息**。

### 试题二（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某新能源汽车公司为了提升效率。需开发一个汽车零件采购系统。请完成系统的数据库设计。
【概念结构设计】
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-2-1.png)

【需求描述】
（1）记录供应商的信息，包括供应商的名称地地和一个电活。
（2）记录零件的信息，包括零件的编码，名称和价格。
（3）纪录车型信息，包括车型的编号，名称和规格。
（4）记录零件采购信息，某个车型的某种零件可以从多家供应商采购，某种零件也可以被多个车型采用，某家供应商也可以供应多种零件，还包括采购数量和采购日期。

【逻辑结构设计】
根据概念结构设计阶段完成的实体联系图，得出如下关系模式（不完整）：
供应商（名称，地址，电话）
零件（编码各称，价格）
车型（编号，各称，规格）
采购（车型编号，供应商名称，（a），（b），采购日期）

【问题1】（5分）根据描进，补充图1的实体联系图（不增加新的实体）。

- ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-2-2.png)

【问题2】（3分）补充逻结构设计结果中的（a），（b）两处空缺，并标注主键和外键完整性约束。

- （a）：零件编码。

  （b）：采购数量。

【问题3】（7分）该汽车公司现新增如下需求:记录车型在全国门店的销售情况，门店信息包括门店的编号，地址和电话，销售包括销售数量和销售日期等。对原有设计进行以下修改以实现该需求：
（1）在图1中体现门店信息及其车型销售情况、并标明新增的实体和联系，及其主要属性。
（2）给出新增加的关系模式，并标注主键和外键完整性约束。

- （1）：![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-2-3.png)

  （2）：主键：**门店（编号，地址，电话）**；外键：**销售（门店编号，车型编号，销售数量，销售日期）**。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
某高校图书馆购买了若干学术资源的镜像数据库（MinorDB）资源，现要求开发—套数字图书馆（Digitallibrary）系统,面向校内用户（User）提供学术资源（Resoure）的浏览，检索和下载服务系统的主要要求描述如下:
（1）系统中存储了每个镜像数据库的基本信息，已投教据库名称，访问地址，数据库属性以及数据库简介等信息，用户进入某个镜像数据降后，可以浏览检索以及下载其中的学术资源。
（2）学术资源包括会议论文（ConferencePaper）、期刑论文（JoumalArtide）以及学位（Thesis）等:系统中存储了每个学术资源的题名、作者、发表时间、来源（哪个镜像数据库）、被引次数、下载次数等信息。对于会议论文，还需记录会议名称，召开时间以及召开地点；同一次会议的论文被收泵在会议集（Proceeaing）中。对于期刊论文，还需记录期刊名称，出版月份，期号以及主办单位；同一期号的论文被收录在—本期刊（Edition）中。对于学位论文，记录了学位类别（博士/硕士），毕业学校，专业及指导教师。会议集包含发表在该会议（在某个特定时间段，特定地点召开）上的所有文章。期刊的每—期在特定时间发行，其中包含若干篇文章。
（3）系统用户（User）包括在校学生（Student），教师（Teacher）以及其他在职人员（Staff）。用户使用学校的统—身份认证登录系统后，使用系统提供的各项服务。
（4）系统提供多种资源检索的方式，主要包括:按照资源的题名检索（SearchbyTite），按照作者名称检票（SearchByAathor），按照来源检索（SearchBySource）等。
（5）用户可以下载资源，系统记录每个资源被下载的次数。现采用面向对象分析与设计方法开发该系统，得到如图1所乐的用例图以及图2所示的初始类图。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-3-1.png)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2023s-3-2.png)

【问题1】（8分）根据说明中的描述，给发图2中的C1～C8所对应向类名。

- **C1：Resoure**；
  **C2：ConferencePaper**；
  **C3：JoumalArtide**；
  **C4：Thesis**；
  **C5：User**；
  **C6：Student**；
  **C7：Teacherc**；
  **C8：Staff**。
  （C6～C8不限制顺序）

【问题2】（4分）根据说明中的描述，给出图2的类C1～C4的关键属性。

- **C1：题名、作者、发表时间**。
  **C2：题名、作者、发表时间、会议名称，召开时间**。
  **C3：题名、作者、发表时间、期刊名称、期号**。
  **C4：题名、作者、发表时间、毕业学校，专业**。

【问题3】（3分）在该系统的开发过程中遇到了新的要求；用户能够在系统中对其所关注的数字资源注册他引通知，若该资源的他引次数发生变化，系候可以及时通知该用户，为了实现这个新的要求，可以在图2所系的类图中增加哪种设计模式？用150字以内文字解释选择该模式的原因。

- **观察者模式**。**观察者模式定义对象间的一对多的关系关系，当一个对象的对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新**。这符合系统需求。

### 试题四（共15分）

- ⚠暂无真题。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在对应栏内。
【说明】
在某系统中，类interval代表由下界（lower bound）和上界（upper bound）定义的区间。要求采用不同的格式显示区间范围。如（lower bound.upper bound） ；（lower bound...upper bound）；（lower bound-upper bound）等现采用策略（strategy）模式实现该要求，得到如图5-1所示的类图。

【C++代码】

```c++
#include "iostream"
#include "string"

using namespace std;
class PrintStrategy {
public:
    __(1)__;
};

class Interval {
private:
    double LowerBound:
    double upperBound;
public:
    Interval(double P_lower, double P_upper) {
        LowerBound = P_Lower:
        upperBound = P_upper;
    }
    void PrintInterval(Printstrategy pt) { __(2)__; }
    double getLower() { return lowerBound; }
    double getUpper() { return upperBound; }
};

class PrintIntervalsComma : public PrintStrategy {
public:
    void doPrint(Interval *val) {
        cout << "[ " << val->getLower() << ", " << val->getupper() << "]" << endl;
    }
};

class PrintIntervalsDots : public PrintStrategy {
public:
    void doPrint(Interval *val) {
        cout << " [ " << val->getLower() << "..." << val->getupper() << "]" << endl;
    }
};

class PrintIntervalsLine : public PrintStrategy {
public:
    void doPrint(Interval *val) {
        cout << " [ " << val->getLower() << "..." << val->getupper() << "]" << endl;
    }
};

enum TYPE {
    COMMA, DOTS, LINE
};

PrintStrategy* getPrintStrategy(int type) {
    PrintStrategy *st;
    switch (type) {
        case COMMA:
            __(3)__;
            break;
        case DOTs:
            __(4)__;
            break;
        case LINE:
            __(5)__;
            break;
    }
    return st;
}

int main() {
    Interval a(1.7, 2.1);
    a.PrintInterval(getPrintstrategy(COMMA));
    a.PrintInterval(getPrintStrategy(DOTs));
    a.PrintInterval(getPrintstrategy(LINE));
}
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）：**`void doPrint (interval *val)`**

  （2）：**`pr->doPrint(this)`**

  （3）：**`st = new printIntervalsComma()`**

  （4）：**`st = new printIntervalsDots()`**

  （5）：**`st = new printIntervalsLine()`**

------

## 2022年下半年案例试题

### 试题一（15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
随着新能源车数量的迅猛增长，全国各地电动汽车配套充电桩急速增长，同时也带米了允电桩计修准确性的问题。充电桩都需要配备相应的电能计量和电费计费功能，需要对充电计量准确性强制进行检定。现需开发计量检定云端软件，其主要功能是：
（1）数据接收。接收计量装置上报的充电数据，即充电过程中电压、电流、电能等充电监测数据和计量数据（充电监测数据为充电桩监测的数据，计量数据为计量装置计量的数据，以秒为间隔单位），接收计量装置心跳数据，并分别进行存储。
（2）基础数据维护。管理员对充电桩、计量检定装置等基础数据进行维护。
（3）数据分析。实现电压、电流、电能数据的对比，进行误差分析，记录充电桩的充电误差，供计量装置检定。系统根据计量检测人员给出的查询和统计条件展示查询统计结果。
（4）充电桩检定。分析充电误差：计量检测人员根据误差分析结果和检定信息记录，对充电桩进行检定，提交检定结果:系统更新充电桩中的检定信息（检定结果和检定时间），并存储于检定记录。
（5）异常告警。检测计量装置心跳，当心跳停止时，向管理员发出告警。
（6）检定信息获取，供其它与充电桩相关的第三方服务查询充电桩中的检定信息。
现采用结构化方法对计量检定云端软件进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-1-1.jpg" style="zoom:80%;" />

<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-1-2.jpg" style="zoom:80%;" />

【问题1】（4分）使用说明中的词语，给出图1-1中的实体E1～E4的名称。

- **E1：计量装置**；
  **E2：管理员**；
  **E3：计量检测人员**；
  **E4：第三方服务**。

【问题2】（5分）使用说明中的词语，给出图1-2中的数据存储D1～D5的名称。

- **D1：充电检测及计量数据文件**；
  **D2：基础信息文件**；
  **D3：计量装置心跳数据**；
  **D4：充电误差信息**；
  **D5：检定记录**。

【问题3】（4分）根据说明中的词语，补充图1-2中缺失的数据流及其起点和终点。

|          数据流          | 起点 | 终点 |
| :----------------------: | :--: | :--: |
|      查询和统计条件      |  E3  |  P3  |
| 更新检定信息（检定记录） |  P4  |  D5  |
|   检定信息（检定记录）   |  D5  |  P6  |
|       充电误差信息       |  D4  |  P3  |

【问题4】（2分）根据说明，给出“充电监测与计量数据”数据流的组成。

- 充电过程中电压、电流、电能等充电监测数据和计量数据（充电监测数据为**充电桩监测的数据**，计量数据为**计量装置计量的数据**，以秒为间隔单位）。

### 试题二（15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】

某营销公司为了便于对各地的分公司及专卖店进行管理，拟开发—套业务管理系统，请根据下述需求描述完成该系统的数据库设计。
【需求描述】
（1）分公司信息包括：分公司编号、分公司名、地址和电话。其中，分公司编号唯—确定分公司关系的每一个元组。每个分公司拥有多家专卖店，每家专卖店只属于一个分公司。
（2）专卖店信息包括：专卖店号、专卖店名、店长、分公司编号、地址、电话，其中店号唯─确定专卖店关系中的每一个元组。每家专卖店只有一名店长，负责专卖店的各项业务：每名店长只负责一家专卖店：每家专卖店有多名职员，每名职员只属于一家专卖店。
（3）职员信息包括：职员号、职员名、专卖店号、岗位、电话、薪资。其中，职员号唯一标识职员关系中的每一个元组。岗位有店长、营业员等。

【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图（不完整）如图2-1所示。
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-2-1.jpg" style="zoom:80%;" />

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）：
分公司（分公司编号，分公司名，地址，电话）
专卖店（专卖店号，专卖店名，（a），职员，地址，电话）
职员（职员号，职员名，（b），岗位，电话，薪资）

【问题1】（6分）根据需求描述，图2-1实体联系图中缺少三个联系。请在答题纸对应的实体联系图中补充三个联系及联系类型。
注：联系名可用联系1、联系2、联系3；也可根据你对题意的理解取联系名。

- 联系1 **分公司和专卖店**：`1:*`（—对多）
  联系2 **专卖店和店长**：`1:1`
  联系3 专**卖店和职员**：`1:*`（—对多）

【问题2】（6分）
（1）将关系校式中的空（a）、（b）的属性补充完整，并填入答题纸对应的位置上。
（2）专卖店关系的主键：（c）和外键（d）。
（3）职员关系的主键：（e）和外键（f）。

- （1）（a）**店长、分公司编号**（b）**专卖店号**
  （2）（c）**专卖店号**（d）**店长、分公司编号**
  （3）（e）**职员号** （f）**专卖店号**

【问题3】（3分）为了在紧急情况发生时，能及时联系到职员的家人，专卖店要求每位职员至少要填写位紧急联系人的姓名、与本人关系和联系电话。根把这种情况，在用2-1中还需来机的实体（g），职员关系与该实体的联系类型为（h）。给出该实体的关系模式。

- （1）（g）**紧急联系人**（h）`1:*` （—对多）
  （2）**紧急联系人（紧急联系人号，职员号，紧急联系人姓名，与本人关系，联系电话）**。

### 试题三（15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
图3-1所示为某软件系统中一个温度控制模块的界面。界面上提供了两种温度计量单位，即华氏度（Fahrenheit）和摄氏度（Celsius）。软件支持两种计量单位之间的自动换算，即若输入一个华氏度的温度，其对应的摄氏度温度值会自动出现在摄氏度的显示框内，反之亦然。用户可以通过该界面上的按钮Raise（升高温度）和Lower（降低温度）来改变温度的值。界面右侧是个温度计，将数字形式的温度转换成温度计上的制度比例进行显示。当温度值改变时，温度计的显示也随之同步变化。
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-3-1.png" style="zoom:80%;" />

<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-3-2.png" style="zoom:80%;" />

【问题1】（4分）根据说明中的描述，给出图3-2中U1～U4所对应的用例名。

- **U1：显示温度**；
  **U2：显示华氏度**；
  **U3：温度计显示**；
  **U4：自动换算**。

【问题2】（8分）根据说明中的描述，给出图3-3中C1～C8所对应的类名（类名使用图3-1中标注的词汇）。

- |  类  |            类名             |      备注      |
  | :--: | :-------------------------: | :------------: |
  |  C1  | `TemperatureCovertorDialog` |       -        |
  |  C2  |     `FahrenheitEditBox`     | C1～C4顺序可换 |
  |  C3  |      `CelsiusEditBox`       | C1～C4顺序可换 |
  |  C4  |      `TemperatureBar`       | C1～C4顺序可换 |
  |  C5  |      `FahrenheitRaise`      | C5～C8顺序可换 |
  |  C6  |      `FahrenheitLower`      | C5～C8顺序可换 |
  |  C7  |       `CelsiusRaise`        | C5～C8顺序可换 |
  |  C8  |       `CelsiusLower`        | C5～C8顺序可换 |

【问题3】（3分）现需将图3-1所示的界面改造为个更为通用的GUI应用，能够实现任意计量单位之间的换算，例如千克和确之间的模算、厘米和英寸之间的换算等等。为了实现这个新的需求，可以在图3-3所示的类图上增加哪种设计模式?请解释选择该设计模式的原因（不超过50字）。

- **策略模式**，此模式可以定义一系列的算法策略，把它们一个个封装起来，并且使它们可以相互替换。在需要指定的计量单位换算时，调用相应的算法策略即可。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
试题排序是将一组无序的数据元素调整为非递减顺序的数据序列的过程，堆排序是—种常用的排序算法。用顺序存储结构存储堆中元素。非递减堆排序的步骤是：
（1）将含n个元素的待排序数列构造成一个初始大顶堆，存储在数组R（R[1]，R[2]，...，R[n]）中。此时堆的规模为n，堆顶元素R[1]就是序列中最大的元素，R[n]是堆中最后一个元素。
（2）将堆顶元素和堆中最后一个元素交换，最后一个元素脱离堆结构，堆的规模减1，将堆中剩余的元素调整成大顶堆;
（3）重复步骤（2），直到只剩下最后一个元素在堆结构中，此时数组R是一个非递减的数据序列。

【C代码】
主要常量和变量说明：`n`是待排序的数组长度，`R[]`是待排序数组，`n`个数放在R[1]，R[2]，...，R[n]中。

```c
#include <stdio.h>
#define MAXITEM 100

/*
调整堆
R: 待排序数组;
v: 节点编号, 以v为根的二叉树, R[v]≥R[2v], R[v]≥R[2v+1], 且其左子树和右子树都是大顶堆;
n: 堆结构的规模, 即堆中的元素数
*/
void Heapify(int R[MAXITEM], int v, int n) {
    int i, j;
    i = v;
    j = 2*i;
    R[0] = R[i];
    while(j <= n) {
        if(j<n && R[j]<R[j+1]) {
            j++;
        }
        if(__(1)__) {
            R[i] = R[j];
            i = j;
            j = 2*i;
        } else {
            j = n+1;
        }
    }
    R[i] = R[0];
}

/* 堆排序，R为待排序数组，n为数组大小 */
void HeapSort(int R[MAXITEM], int n) {
    int i;
    for(i = n/2; i>=1; i--) {
        __(2)__;
    }
    for(i = n; __(3)__; i++) {
        R[0] = R[i];
        R[i] = R[1];
        __(4)__;
        Heapify(R, 1, i-1);
    }
}
```

【问题1】（8分）根据以上说明和C代码，填充C代码中的空（1）～（4）。

- （1）**`R[0]<R[j]`**

  （2）**`Heapify(R, i, n)`**

  （3）**`i>=1`**

  （4）**`R[1]=R[0]`**

【问题2】（2分）根据以上说明和C代码，算法的时间复杂度为（5）（用O符号表示）。

- 算法的时间复杂度为$O(n×log_2N)$。

【问题3】（5分）考虑数据序列$R=(7, 10, 13, 15, 4, 20, 19, 8)$，`n = 8`，则构建的初始大顶堆为（6），第一个元素脱离堆结构，对剩余元素再调整成大顶堆后的数组R为（7）。

- （6）**20，15，19，10，4，13，7，8**
  （7）**19，15，13，10，4，8，7**

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。
【说明】
Facade（外观）模式是一种通过为多个复杂子系统提供—个一致的接口，而使这些子系统更加容易被访问的模式，以医院为例，就医时患者需要与医院不同的职能部门交互，完成挂号、门诊、取药等操作。为简化就医流程，设置了一个接待员的职位，代患者完成上述就医步骤，患者则只需与接待员交互即可。如图5-1给出了以外观模式实现该场景的类图。
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022x-5-1.png" style="zoom:80%;" />

```c++
#include <iostream>
#include <string>
using namespace std;

class Patient {
public:
    __(1)__;
};

class Disposer {
public:
    __(2)__;
};

class Registry : public Disposer {  // 挂号
public:
    void dispose(Patient *patient) {
        cout << "I am registering ..." << patient->getName() << endl;
    }
};

class Doctor : public Disposer {  // 医生门诊
public:
    void dispose(Patient *patient) {
        cout << "I am disposing ..." << patient->getName() << endl;
    }
};

class Pharmacy : public Disposer {  // 取药
    void dispose(Patient *patient) {
        cout << "I am giving medicine ..." << patient->getName() << endl;
    }
};

class Facade {
private:
    Patient *patient;
public:
    Facade(Patient *patient) { this->patient = patient; }
    void dispose() {
        Registry *registry = new Registry();
        Doctor *doctor = new Doctor();
        Pharmacy *ph = new Pharmacy();

        registry->dispose(patient);
        doctor->dispose(patient);
        ph->dispose(patient);
    }
};

class ConcretePatient : public Patient {
private:
    string name;
public:
    ConcretePatient(string name) {this->name = name;}
    string getName() { return name; }
};

int main() {
    Patient *patient = __(3)__;
    __(4)__ f = __(5)__;
    __(6)__;
    return 0; 
}
```

【问题1】（15分）填充C++代码中的空（1）～（6）。

- （1）**`virtual string getName() =0`**
  （2）**`virtual void dispose(Patient *patient)=O`**
  （3）**`new ConcretePatient("name")`**
  （4）**`Facade *`**
  （5）**`new Facade (patient)`**
  （6）**`f->dispose()`**

------

## 2022年上半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某公司欲开发一款外卖订餐系统，集多家外卖平台和商户为一体，为用户提供在线浏览餐品、订餐和配送等服务。该系统的主要功能是:
（1）入驻管理。用户注册：商户申请入驻，设置按时间段接单数量阅值等。系统存储商户/用户信息。
（2）餐品管理。商户对餐品的基本信息和优惠信息进行发布、修改、删除。系统存储相关信息。
（3）订餐。用户浏览商户餐单，选择餐品及数量后提交订餐请求。系统存储订餐订单。
（4）订单处理。收到订餐请求后，向外卖平台请求配送。外卖平台接到请求后发布配送单，由平台骑手接单，外卖平台根据是否有骑手接单返回接单状态。若外卖平台接单成功，系统给支付系统发送支付请求，接收支付状态。支付成功，更新订单状态为已接单，向商户发送订餐请求并由商户打印订单，给用户发送订单状态：若支付失败，更新订单状态为下单失败，向外卖平台请求取消配送，向用户发送下单失败。若系统接到外卖平台返回接单失败或超时未返回接单状态，则更新订单状态为下单失败，向用户发送下单失败。
（5）配送。商户备餐后，由骑手取餐配送给用户。送达后由用户扫描骑手出示的订单上的配送码后确认送达，订单状态更改为已送达，并发送给商户。
（6）订单评价。用户可以对订单餐品、骑手配送服务进行评价，推送给对应的商户、所在外卖平台，商户和外卖平台对用户的评价进行回复。系统存储评价。现采用结构化方法对外卖订餐系统进行分析与设计，获得如图1-1所示的上下文数据。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-1-1.jpg)

流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-1-2.jpg)

【问题1】（4分）使用说明中的词语，给出图1-1的实体E1～E4的名称。

- **E1：商户**；
  **E2：外卖平台**；
  **E3：用户**；
  **E4：支付系统**。

【问题2】（4分）使用说明中的词语，给出图1-2中的数据存储D1～D4的名称。

- **D1：用户/商户信息**；
  **D2：订餐订单信息**；
  **D3：餐品信息**；
  **D4：评价信息**。

【问题3】（4分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |    数据流    |      起点      |      终点      |
  | :----------: | :------------: | :------------: |
  |     餐单     |   P3 或 订餐   |   E3 或 用户   |
  |     餐单     | D3 或 餐品信息 |   P3 或 订餐   |
  |   订餐状态   |   P3 或 订餐   | P4 或 订单处理 |
  | 更新订单状态 | P4 或 订单处理 | D2 或 订单信息 |
  |    配送码    |   P5 或 配送   |   E3 或 用户   |

【问题4】（3分）根据说明，采用结构化语言对“订单处理”的加工逻辑进行描述。

```
收到订餐请求后，向外卖平台请求配送;
外卖平台接到请求后发布配送单，由平台骑手接单;
外卖平台根据是否有骑手接单返回接单状态;
IF(外卖平台接单成功) THEN {
    系统给支付系统发送支付请求，接收支付状态;
    IF(支付成功) THEN {
        更新订单状态为已接单;
        向商户发送订餐请求并由商户打印订单;
        给用户发送订单状态;
    } ELSE {
        更新订单状态为下单失败;
        向外卖平台请求取消配送;
        向用户发送下单失败;
    }
    ENDIF
} ELSE IF(系统接到外卖平台返回接单失败或超时未返回接单状态) THEN {
    更新订单状态为下单失败;
    向用户发送下单失败;
    }ENDIF
}ENDIF
```

### 试题二（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
为了提高接种工作，提高效率，并未了机击投情握供疫苗接种数据支撑，需要开发一个信息系统，下述需求完成该系统的数据库设计。
（1）记录疫苗供应商的信息，包括供应商名称，地址和一个电话。
（2）记录接种医院的信息，包括医院名称、地址和一个电话。
（3）记录接种者个人信息，包括姓名、身份证号和一个电话。
（4）记录接种者疫苗接种信息，包括接种医院信息，被接种者信息，疫苗供应商名称和接种日期，为了提高免疫力，接种者可能需要进行多次疫苗接种，（每天最多接种—次，每次都可以在全市任意一家医院进行疫苗接种）。

【概念模型设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）：
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-2-1.jpg)

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）：
供应商（供应商名称、地址、电话）
医院（医院名称、地址、电话）
供货（供应商名称，（a），供货内容）
被接种者（姓名、身份证号、电话）
接种（接种者身份证号，（b），医院名称、供应商名称）

【问题1】（4分）根据问题描述，补充图2-1的实体联系图（不增加新的实体）。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-2-2.jpg)

【问题2】（4分）补充逻辑结构设计结果中的（a）（b）两处空缺，并标注主键和外健完整性约束。

- （a）**医院名称**；
  （b）**接种时间**。

  |  -   |             主键             |                 外键                 |
  | :--: | :--------------------------: | :----------------------------------: |
  | 供货 |   （供货商名称，医院名称）   |         供应商名称，医院名称         |
  | 接种 | （接种者身份证号，接种时间） | 接种者身份证号，供应商名称，医院名称 |

【问题3】（7分）若医院还兼有核酸检测的业务，检测时可能需要进行多次植酸检测（每天最多检测一次），但每次都可以在全市任意一家医院进行检测。请在图2-1中增加“被检测者”、实体及相应的属性。医院与被检测者之间的“检测”联系及必要的属性，并给出新增加的关系模式。“被检测者”实体包括姓名、身份证号、地址和一个电话。“检测“联系需要包括检测日期和检测结果等。

- 新增关系模式：
**被检测者（身份证号，姓名，地址，电话）**
**检测（被检测者身份证号，医院名称，检测日期，检测结果）**

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某公司的人事能门拥有一个地址簿（`AddressBookSystem`），管理系统（`addressBookSystem`），用于管理公司所有员工的地址记录（`PersonAddress`）。员工的地址记录包括:姓名、住址、城市、省份、邮政编码以及联系电话等等信息。
管理员可以完成对地址簿中地址记录的管理操作，包括：
（1）维护地址记录。根据司的人员变动情况，对地址记录进行添加、修改、删除等操作。
（2）排序。按照员工姓氏的字典顺序或邮政编码对址领中的所有记录。
（3）打印地址记录。以邮件标签的格式打印一个地址单独的地址簿。
系统会记录管理为便于管理，管理员在系统中为公可的不同部门建立员对每个地址簿的修改操作，包括：
（1）创建地址簿。新建个地址簿并保存。
（2）打开地址簿。打开——个已有的地址簿。
（3）修改地址簿。对打开的地址簿进行修改并保存系统将提供一个GUI（图形用户界面）实现对地址簿的各种操作。
现采用面向对象方法分析并设计该地址簿管理系统，得到如图3-1所示的用例图和图3-2所示的类图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-3-1.jpg)
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-3-2.jpg" style="zoom:68%;" />

【问题1】（6分）根据说明中的描述，给出图3-1中U1～U6所对应的用例名。

- **U1：按姓氏字典顺序排序**；
  **U2：按邮政编码排序**；（U1和U2可互换）
  **U3：创建地址簿**；
  **U4：修改地址簿**；
  **U5：打开地址簿**；
  **U6：保存地址簿**。

【问题2】（5分）根据说明中的描述，给出图3-2中类`AddressBook`的主要属性和方法以及类`PersonAddress`的主要属性（可以使用说明中的文字）。

- 类`PersonAddress`的主要屋性包括：姓名、住址、城市、省份、邮政编码以及联系电话等。类`AddressBook`的主要屋性包括：部门名/编号，姓名、住址、城市、省份、邮政编码以及联系电话等。类`AddressBook`的需要包括创建地址簿、打开地址簿、修改地址簿。综上所述，类`AddressBook`的方法包括：添加、修改、删除、创建、打开、打印、排序等。

【问题3】（4分）根据说明中的描述以及图31所示的用例图，请问`extend`和`include`关系的含义是什么？

- `extend`属于用例图的三种关系之一，表示的是扩展关系。描述为：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能会发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，关系图示指向为扩展用例指向基本用例。
  创建和打开就是一对扩展关系，创建成功之后可以直接保存关闭之后，如果想要进行后续修改工作，就需要打开地址簿，由扩展用例指向基本用例。

  `include`属于用例图的三种关系之一，表示的是包含关系。描述为：当可以从两个或两个以上用例中提取公共行为的时候，应该使用包含关系来表示它们。其中这个提取出来的公共用例称之为抽象用例，而把原始用例称为基本用例和基础用例。创建、修改和保存就是一对包含关系，在创建和修改它们都有公共的行为保存，提取出来称之为抽象用例，用包含关系表示它们。

### 试题四（共15分）

【问题1】
阅读下列说明和C代码，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
工程计算中经常要完成多个矩阵相乘的计算任务，对矩阵相乘进行以下说明。
（1）两个矩阵相乘要求第一个矩阵的列数等于第二个矩阵的行数，计算量主要由进行乘法运算的次数决定，假设采用标准的矩阵相乘算法，计算$A_{m×n}×B_{n×p}$需要$m×n×p$次行乘法运算的次数决定、乘法运算，即时间复杂度为$O(m×n×p)$。
（2）矩阵相乘满足结合律，多个矩阵相乘时不同的计算顺序会产生不同的计算量。以矩阵$A_{15×100}$，$A_{2100×8}$，$A_{38x50}$三个矩阵相乘为例，若按$(A_1×A_2)×A_3$计算，则需要进行$5×100×8+5×8×50=6000$次乘法运算，若按$A_1×(A_2×A_3)$计算，则需要进行$100×8×50+5×100×50=65000$次乘法运算。矩阵链乘问题可描述为：给定n个矩阵对较大的，
可能的计算顺序数量非常庞大，用蛮力法确定计算顺序是不实际的。经过对问题进行分析，发现矩阵链乘问题具有最优子结构，即若$A_1×A_2×...×A_n$的一个最优计算顺序从第$k$个矩阵处断开，即分为$A_1×A_2×...×A_k$和$A_{k+1}×A_{k+2}×...×A_n$两个子问题，则该最优解应该包含$A_1×A_2×...×A_k$的一个最优计算顺序和$A_{k+1}×A_{k+2}×...×A_n$的一个最优计算顺序。据此构造递归式：
$$
\cos t[i][j]=\left\{\begin{array}{ll}
0 & \text {if i = j }\\
\min_{i ≤ k < j} \{\cos t[i][k]+\cos t[k+1][j]+p_i×(p_{k+1}×P_{j+1})\} & \text {if i < j} \\
\end{array}\right.
$$
其中，`cost[i][j]`表示$A_{i+1}×A_{i+2}×...×A_{j+1}$的最优计算的计算代价。最终需要求解cost[0][n-1]。

【C代码】算法实现采用自底向上的计算过程。首先计算两个矩阵相乘的计算量，然后依次计算3个矩阵、4个矩阵、...、n个矩阵相乘的最小计算量及最优计算顺序。该算法的主要常量和变量说明：`n`是矩阵数，`seq[]`是矩阵维数序列，`cos[i][j]`是长度为`n×n`的二维数组，其中元素`cost[i][j]`表示$A_{i+1}×A_{i+2}×...×A_{j+1}$的最优计算代价；`trace[]`是长度为`n×n`的二维数组，其中元素`trace[i][j]`表示$A_{i+1}×A_{i+2}×...×A_{j+1}$的最优计算代价对应的划分位置，即`k`。

```c
#define N 100

int cost[N[N];
int trace[N][N];
int cmm(int n, int seq[]) {
    int tempCost;
    int tempTrace;
    int i, j, k, p;
    int temp;
    for(i=0; i<n; i++) { 
        cost[i][i] = 0;
    }
    for(p=1; p<n; p++) {
        for(i=0; i<n-p; i++) {
            __(1)__;
            tempCost = -1;
            for(k=i; __(2)__; k++) {
                temp= __(3)__;
                if(tempCost==-1 || tempCost>temp) {
                    tempCost = temp;
                    tempTrace=k;
                }
            }
            cost[i][j] = tempCost;
            __(4)__;
        }
    }
    return cost[0][n-1];
}
```

【问题1】（8分）根据以上说明和C代码，填充C代码中的空（1）～（4）。

- （1）**`j=i+p`**
  （2）**`k`**
  （3）**`cost[i][k]+cost[k+1][j]+seq[i]*seq[k+1]*seq[j+1]`**
  （4）**`trace[i][j] = tempTrace`**

【问题2】（4分）根据以上说明和C代码，该问题采用了（5）算法设计策略，时间复杂度为（6）（用O符号表）。

- （5）**动态规划算法**
  （6）$O(n^3)$

【问题3】（3分）考虑实例n=4，各个矩阵的维数为$A_1$为15×5，$A_2$为5×10，$A_3$为10×20，$A_4$为20×25，即维度序列为15，5，10，20和25。则根据上述C代码得到的一个最优计算顺序为（7）（用加括号方式表示计算顺序），所需要的乘法运算次数为（8）。

- （7）$A_1×((A_2×A_3)×A_4)$
  （8）**5375**

### 试题五（共15分）

阅读下列说明和C++代码。将应填入（n）处的字句写在答题纸的对应栏内。
【说明】
在软件系统中，通常都会给用户提供取消、不确定或者错误操作的选择，允许将系统恢复到原先的状态。现使用备忘录（`Memento`）模式实现该要求，得到如图5-1所示的类图。`Memento`包含了要被恢复的状态。`Originator`创建并在`Memento`中存储状态。`Caretaker`负责从`Memento`中恢复状态。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2022s-5-1.jpg)

【C++代码】

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Memento{
private:
    string state;
public:
    Memento(string state) { this->state=state; }
    string getState() { return state; }
};

class Originator{
private:
    string state;
public:
    void setState(string state) { this>sate-state; }
    string getState() { return state; }
    Memento saveStateToMemento() { return __(1)__; }
    void getStateFromMemento(Memento Memento) { state = __(2)__; }
};

class CareTaker{
private:
    vector<Memento> mementoList;
pubilc:
    void __(3)__ { 
        mementoList.push_back(state);
        __(4)__;
        return mementoList(index);
    }
};

int main() {
    Originator*originator = new Originator();
    CareTaker*careTaker = new CareTaker();
    originator->setState("State #1");
    originator->setState("State #2");
    careTaker->add(__(5)__);
    originator->setState("State #3");
    careTaker->add(__(6)__);
    originator->setState("State #4");
    cout << "Current State:" << "+" << originator->getState() << endl;
    originator->getStateFromMemento(careTaker->get(0);
    cout << "First saved State:" << originator->getState() << endl;
    originator->getStateFromMemento(careTaker->get(1));
    cout << "second save State" << "+" << originator->getState() <<endl;
    return 0;
}
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`new Memento(state)`**
  （2）**`Memento->getState()`**
  （3）**`add(Memento * state)`**
  （4）**`Memento * get(int index)`**
  （5）**`originator->saveStateToMemento()`**
  （6）**`originator->saveStateToMemento()`**

------

## 2021年下半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。

【说明】
某现代农业种植基地为进一步提升农作物种植过程的智能化，欲开发智慧农业平台，集管理和销售于—体，该平台的主要功能有：
（1）信息维护。农业专家对农作物、环境等监测数据的监控处理规则进行维护。
（2）数据采集。获取传感器上传的农作物长势、土壤墒情、气候等连续监测数据，解析后将监测信息进行数据处理、可视化和存储等操作。
（3）数据处理。对实时监测信息根据监控处理规则进行监测分析，将分析结果进行可视化并进行存储、远程控制对历史监测信息进行综合统计和预测，将预测信息进行可视化和存储。
（4）远程控制。根据监控处理规则对分析结果进行判定，依据判定结果自动对控制器进行远程控制。平台也可以根据农业人员提供的控制信息对控制器进行远程控制。
（5）可视化。实时向农业人员展示监测信息；实时给农业专家展示统计分析结果和预测信息或根据农业专家请求进行展示。现采用结构化方法对智慧农业平台进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021x-1-1.jpg)

【问题1】（4分）使用说明中的词语，给出图1-1中的实体E1～E4的名称。

- **E1：传感器**；
  **E2：农业专家**；
  **E3：农业人员**；
  **E4：控制器**。

【问题2】（4分）使用说明中的词语，给出图1-2中的数据存储D1～D4的名称。

- **D1：监控处理规则文件**；
  **D2：监测信息表**；
  **D3：分析结果文件**；
  **D4：预测信息表**。

【问题3】（4分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |  数据流  | 起点 | 终点 |
  | :------: | :--: | :--: |
  |   规则   |  D1  |  P4  |
  |   请求   |  E2  |  P5  |
  | 分析结果 |  D3  |  P5  |
  | 预测信息 |  D4  |  P5  |

  起点D1，终点P4，规则；
  起点E2，终点P5，请求；
  起点D3，终点P5，分析结果；
  起点D4，终点P5，预测信息。

【问题4】（3分）根据说明，“数据处理"可以分解为哪些子加工？进一步进行分解时，需要注意哪三种常见的错误？

- “数据处理加工”可分为**数据分析**，**可视化与存储**；需要注意的常见错误有：黑洞、奇迹、灰洞。

### 试题二（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。

【说明】
某汽车维修公司为了便于管理车辆的维修情况，拟开发—套汽车维修管理系统，请根据下述需求描述完成该系统的数据库设计。

【需求描述】
（1）客户信息包括：客户号、客户名、客户性质、折扣率、联系人、联系电话。客户性质有个人或单位。客户号唯一标识客户关系中的每一个元组。
（2）车辆信息包括：车牌号、车型、颜色和车辆类别。一个客户至少有—辆车，—辆车只属于一个客户。
（3）员工信息包括：员工号、员工名、岗位、电徳、豕庭住址。其中，员工号唯一标识员工关系中的每一个元组。岗位有业务员、维修工、主管。业务员根据车辆的故障情况填写维修单。
（4）部门信息包括：部门号、名称、主管和电话，其中部门号唯─确定部门关系的每一个元组。每个部门只有一名主管，但每个部门有多名员工，每名员工只属于一个部门。
（5）维修单信息包括：维修单号、车牌号、维修内容、工时。维修单号唯—标识维修单关系中的每一个元组。一个维修工可接多张维修单，但—张维修单只对应一个维修工。

【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图（不完整）如图2-1所示。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021x-2-1.png)

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）:
客户（客户号，客户名，（a;折扣率，联系人，联系电话）
车辆（车牌号，（b），车型，颜色，车辆类别）员工（员工号，员工名，岗位，（c），电话，家庭住址）
部门（部门号，名称，主管，电话）
维修单（维修单号，（d），维修内容，工时）
【问题1】（6分）根据问题描述，补充3个联系，完善图2-1的实体联系图。联系名可用联系1、联系2和联系3代替，联系的类型为`1:1`、`1:n`和`m:n`（或`1:1`、`1:*`和`*.*`）。

- 联系1：**客户和车辆，`1:n`**。
  联系2：**部门和员工，`1:n`**。 
  联系3：**维修工和维修单，`1:n`**。

【问题2】（4分）根据题意，将关系模式中的空（a）～（d）的属性补充完整，并填入答题纸对应的位置上。

- a：**客户性质**。
  b：**客户号**。
  c：**部门号**。
  d：**车牌号，员工号**。

【问题3】（2分）分别给出车辆关系和维修单关系的主键与外键。

- 车辆关系的主键：（**车辆号，客户号**）；外键：**客户号**。 
  维修单关系的主键：**维修单号**；外键：**车牌号，员工号**。

【问题4】（3分）如果一张维修单涉及多项维修内容，需要多个维修工来处理，那么哪个联系类型会发生何种变化？你认为应该如何解决这一问题？

- 维修工和维修单之间的联系类型会发生变化，从`1:n`变成`m:n`。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某游戏公司欲开发—款吃金币游戏。游戏的背景为—种回廊式迷宫（Maze），在迷宫的不同位置上设置有墙。迷宫中有两种类型的机器人（Robots）：小精灵（PacMan）和幽灵（Ghost）。游戏的目的就是控制小精灵在迷宫内游走，吞吃迷宫路径上的金币，且不能被幽灵抓到。幽灵在迷宫中游走，并会吃掉遇到的小精灵。机器人游走时，以单位距离的倍数计算游走路径的长度。当迷宫中至少存在一个小精灵和—个幽灵时，游戏开始。机器人上有两种传感器，使机器人具有一定的感知能力。这两种传感器分别是：
（1）前向传感器（FrontSensor），探测在机器人当前位置的左边、右边和前方是否有墙（机器人遇到墙时，必须改变游走方向）。机器人根据前向传感器的探测结果，决定朝哪个方向运动。
（2）近距离传感器（ProxiSesor），探测在机器人的视线范围内（正前方）是否存在隐藏的金币或幽灵。近距离传感器并不报告探测到的对象是否正在移动以及朝哪个方向移动。但是如果近距离传感器的连续两次探测结果表明被探测对象处于不同的位置，则可以推导出该对象在移动。
另外，每个机器人都设置有一个计时器（Timer）用于支持执行预先定义好的定时事件。
机器人的动作包括：原地向左或向右旋转90°；向前或向后移动。
建立迷宫：用户可以使用编辑器（Editor）编写迷宫文件，建立用户自定义的迷宫。将迷宫文件导入游戏系统建立用户自定义的迷宫
现采用面对家分析与设计方法开发该游戏，得到如图3-1所示的用例图以及图3-2所示的初始类图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021x-3-1.jpg)

【问题1】（3分）根据说明中的描述，给出图3-1中U1～U3所对应的用例名。

- **U1：编写迷宫文件**；**U2：导入迷宫文件**；**U3：设置计时器**。

【问题2】（4分）图3-1中用例U1～U3分别与哪个（哪些）用例之间有关系，是何种关系？

- U1和U2与建立迷宫用例是**泛化关系**；U3与操作机器人是**包含关系**。

【问题3】（8分）根据说明中的描述，给出图3-2中C1～C8所对应的类名。

- **C1：机器人(Robos)**；
  **C2：计时器(Timer)**；
  **C3：小精灵(PacMan)**；
  **C4：幽灵(Ghost)**；
  **C5：传感器**；
  **C6：前向传感器(FrontSensor)**；
  **C7：近距离传感器(ProxiSesor) **；
  **C8：迷宫(Maze)**；
  其中C3与C4可换；C6与C7可换。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
生物学上通常采用编辑距离来定义两个物种DNA序列的相似性,从而刻画物种之间的进化关系。具体来说，编辑距离是指将一个字符串变换为另—个字符所需要的最小操作次数。操作有三种，分别为：插入一个字符、删除—个字符以及将一个字符修改为另一个字符。用字符数组`str1`和`str2`分别表示长度分别为`len1`和`len2`的字符串，二维数组`d`记录求解编辑距离的子问题最优解，则该二维数组可以递归定义为：
$$
d[i][j]=\left\{\begin{array}{ll}
i & \text { 若 len2 = 0 }\\
j & \text { 若 len1 = 0 }\\
d[i-1][j-1] & \text { 若 str1[i-1] = str2[j-1] }\\
\min \{d[i-1][j]+1,d[i][j-1]+1,d[i-1][j-1)+1\} & \text { 若 str1[i-1] ≠ str2[j-1] } \\
\end{array}\right.
$$
【C代码】

常量和变量说明：`A`和`B`是两个字符数组，`d`是二维数组，`i`和`j`是循环变量，`temp`是临时变量。

```c
#include <stdio.h>
#define N 100

char A[N] = "CTGA";
char B[N] = "ACGCTA";
int d[N][N];

int min(int a, int b) {
    return a < b ? a : b;
}

int editdistance(char *str1, int len1, char *str2, int len2) {
    int i, j;
    int diff;
    int temp;
    for(int i = 0; i <= len1; i++) {
        d[i][0] = i;
    }
    for(j = 0; j <= len2; j++) {
        __(1)__;
    }
    for(i = 1; i <= len1; i++) {
        for(j = 1; j <= len2; j++) {
            if(__(2)__) {
                d[i][j] = d[i-1][j-1];
            } else {
                temp = min(d[i-1][j]+1, d[i][j-1]+1);
                d[i][j] = min(temp, __(3)__);
            }
        }
    }
    return __(4)__;
}
```

【问题1】（8分）根据说明扣C代码，填充C代码中的空（1）～（4）。

- （1）**`d[0][j]=j`**
  （2）**`str1[i-1]==str2[j-1]`**
  （3）**`d[i-1][i-1]`**
  （4）**`d[len1][len2]`**

【问题2】（4分）根据说明和C代码，算法采用了（5）设计策略，时间复杂度为（6）（用O符号表示，两个字符串的长度分别用`m`和`n`表示）。

- （5）**动态规划法**
  （6）$O(m×n)$

【问题3】（3分）已知两个字符串A="CTGA"和B="ACGCTA"，根据说明和C代码，可得出这两个字符串的编辑距离为（7）。

- 编辑距离是指将一个字符串变换为另—个字符所需要的最小操作次数。操作有三种，分别为：插入一个字符、删除—个字符以及将一个字符修改为另一个字符。字符串"CTGA"变成字符串"ACGCTA"的编辑距离为`4`，先在C前插入字符A，再在C后插入字符G和字符C，此时的字符串为"ACGCTGA"再删除最后一个G字符即可得到"ACGCTA"，因此这两个字符串的编辑距离为`4`。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。

【说明】
享元（flyweight）模式主要用于减少创建对象的数量，以降低内存占用，提高性能。现要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空间，采用享元模式实现该程序，得到如图5-1所示的类图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-5-1.png)

【C++代码】

```c++
#include "iostream"
#include "vector"
using namespace std;

enum PieceColor { BLACK, WHITE };  //棋子颜色
class PiecePos {  //棋子位置
private:
    int x;
    int y;
public:
    PiecePos(int a, int b) : x(a), y(b) {}
    int getX() { return x; }
    int getY() { return y; }
};

class Piece {  //棋子定义
protected:
    PieceColor m_color;  //颜色
    PiecePos m_pos;  //位置
public:
    Piece(PieceColor color, PiecePos pos) : m_color(color), m_pos(pos) {}
    __(1)__;
};

class BlackPiece : public Piece {
public:
    BlackPiece(PieceColor color, PiecePos pos) : Piece(color, pos) {}
    void Draw() { cout << "draw a black piece" << endl; }
};

class WhitePiece : public Piece {
public:
    WhitePiece(PieceColor color, PiecePos pos) : Piece(color, pos) {}
    void Draw() { cout << "draw a white piece" << endl; }
};

class PieceBoard {
private:
    vector<__(2)__> m_vecPiece;  //棋盘上已有的棋子
    string m_blackName;  //黑方名称
    string m_whiteName;  //白方名称
public:
    PieceBoard(string black, string white) : m_blackName(black), m_whiteName(white) {}
    void setPiece(PieceColor color, PiecePos pos) {  //一步棋, 在棋盘上放一颗棋子
        __(3)__ piece = null;
        if(color == BLACK) {  //放黑了
            piece = new BLackPiece(color, pos);  //获取一颗棋子
            cout << m_blackName << "在位置(" << pos.getX() << "," << pos.getY() <<")";
            __(4)__;
        } else {  //放白子
            piece = new BlackPiece(color, pos);  //获取一颗棋子
            cout << m_whiteName << "在位置(" << pos.getX() << "," << pos, getY() <<")";
            __(5)__;
        }
        m_vecPiece.push_back(piece);
    }
};
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- 【问题1】
  （1）**`virtual void Draw(){}`**
  （2）**`Piece*`**
  （3）**`Piece *`**
  （4）**`piece->Draw()`**
  （5）**`piece->Draw()`**

------

## 2021年上半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某停车场运营方为了降低运营成本，减员增效，提供良好的停车体验，欲开发无人值守停车系统，该系统的主要功能是：
（1）信息维护。管理人员对车位（总数、空余车位数等）计费规则等基础信息进行设置。
（2）会员注册。车主提供手机号、车牌号等信息进行注册，提交充值信息（等级、绑定并授权支付系统进行充值或交费的支付账号）不同级别和充值额度享受不同停车折扣点。
（3）车牌识别。当车辆进入停车场时，若有（空余车位数大于1），自动识别车牌号后进行道闸控制，当车主开车离开停车场时，识别车牌号，计费成功后，请求道闸控制。
（4）计费。更新车辆离场时间，根据计费规则计算出停车费用，若车主是会员，提示停车费用:若储存余额够本次停车费用，自动扣费，更新余额，若储值余额不足，自动使用授权缴费账号请求支付系统进行支付，获取支付状态。若非会员临时停车，提示停车费用，车主通过扫描费用信息中的支付码调用支付系统自助交费，获取支付状态。
（5）道闸控制。根据道闸控制请求向道闸控制系统发送放行指令和接收道闸执行状态。若道闸执行状态为正常放行时，对入场车辆，将车牌号及其入场时间信息存入停车记录，修改空余车位数;对出场车辆更新停车状态，修改空余车位数。当因道闸重置系统出现问题（断网断电或是故障为抬杠等情况），而无法在规定的时间内接收到其返回的执行状态正常放行时，系统向管理人员发送异常告警信息，之后管理人员安排故障排查处理，确保车辆有序出入停车场。
现采用结构化方法对无人值守停车系统进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-1-1.jpg)![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-1-2.jpg)

【问题1】（5分）使用说明中的词语，给出图1-1中的实体E1～E5的名称。

- **E1：车辆**；
  **E2：车主**；
  **E3：支付系统**；
  **E4：管理人员**；
  **E5：道闸控制系统**。

【问题2】（3分）使用说明中的词语，给出图1-2中的数据存储D1～D3的名称。

- **D1：停车记录表**；
  **D2：会员信息表**；
  **D3：基础信息表**。

【问题3】（4分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |    数据流    | 起点 | 终点 |
  | :----------: | :--: | :--: |
  | 计费规则信息 |  D3  |  P3  |
  | 道闸控制请求 |  P1  |  P5  |
  | 更新车位信息 |  P5  |  D3  |
  |   更新余额   |  P3  |  D2  |

【问题4】（3分）根据说明，采用结构化语言对“道闸控制”的加工逻辑进行描述。

```
IF(道闸执行状态正常)
	IF(车辆入场) THEN
		将车牌号及其入场时间信息存入停车记录，修改空余车位数
    ELSEIF(车辆出场) THEN
		更新停车状态，修改空余车位数
	ENDIF
ELSESIF(未在规定的时间内接收到其返回的执行状态正常放行)THEN
	向管理人员发送异常告警信息
ENDIF
```

### 试题二（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
某社区蔬菜团购网站为规范商品收发流程、便于查询客户订单情况，需要开发信息系统。请根据下述需求描述完成该系统的数据库设计。

【需求描述】
（1）记录蔬菜供应商的信息，包括供应商编号、地址和一个电话。
（2）记录社区团购点的信息，包括团购点编号、地址和一个电话。
（3）记录客户信息，包括客户姓名和一个电话。客户可以在不同的社区团购点下订单，不直接与蔬菜供应商发生联系。
（4）记录客户订单信息，包括订单编号、团购点编号客户电话，订单内容和日期。

【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图，如图2-1所示。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-2-1.jpg)

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式：
蔬菜供货商（供货商编号，地址，电话）
社区团购点（团购点编号，地址，电话）
供货（供货商编号，（a））
客户（姓名，客户电话)
订单（订单编号，团购点编号，（b），订单内容，日期）
【问题1】（6分）根据问题描述，补充图2-1的实体联系图。

- ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-2-2.jpg)

【问题2】（4分）补充逻辑结构设计结果中的（a）和（b）两处空缺及完整性约束关系。

- （a）**团购点编号**。主键：**供货商编号，团购点编号**；外键：**供货商编号，团购点编号**。
  （b）**客户电话**。主键：**订单编号**；外键：**团购点编号，客户电话**。

【问题3】（5分）若社区蔬菜团购网站还兼有代收快递的业务，请增加新的“快递”实体，并给出客户实体和快递实体之间的“收取”联系，对图1进行补充。“快递”关系模式包括快递编号、客户电话和日期。

- ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-2-3.jpg)

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
某中医医院拟开发—套线上抓药APP，允许患者凭借该医院医生开具的处方线上抓药，并提供免费送药上门服务。该系统的主要功能描述如下：
（1）注册。患者扫描医院提供的二维码进行注册，注册过程中，患者需提供其病历号，系统根据病历号自动获取患者基本信息。
（2）登录。已注册的患者可以登录系统进行线上抓药，未注册的患者系统拒绝其登陆。
（3）确认处方。患者登录后，可以查看医生开具的所有处方。患者选择需要抓药的处方和数量（需要抓几副药），同时说明是否需要煎制。选择取药方式：自行到店取药或者送药上门，若选择送药上门，患者需要提供提供收贷人姓名、联系方式和收货地址。系统自动计算本次抓药的费用，患者可以使用微信或支付宝等支付方式支付费用。支付成功之后，处方被发送给药师进行药品配制。
（4）处理处方。药师根据处方配置好药品，若患者要求煎制，药师对配置好的药品进行煎制。煎制完成，药师将对该处方设置已完成。若患者选择的是自行取药，取药后确认已取药。
（5）药品派送。处方完成后，对于选择送药上门的患者，系统将给快递人员发送药品的配置信息，等待快递人员来取药;并给患者发送收获验证码。
（6）送药上门。快递人员将配置好的药品送到患者指定的收货地址。患者收获时，向快递人员出示收获验证码，快递人员使用该验证码确认药品已送到。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-3-1.jpg)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-3-2.jpg)

【问题1】（7分）根据说明中的描述，给出图3-1中A1～A3所对应的参与者名称和U1～U4处所对应的用例名称。

- **A1：患者；**
  **A2：快递人员；**
  **A3：药师；**
  **U1：确认处方；**
  **U2：支付方式；**
  **U3：微信支付；**
  **U4：支付宝支付**（U3、U4可以互换）。

【问题2】（5分）根据说明中的描述，给出图3-2中C1～C5所对应的类名。

- C1：**支付方式**；
  C2：**微信支付**；
  C3：**支付宝支付**；
  C4：**处方**；
  C5：**药品（C2、C3可以互换**）
  C1：**处方**；
  C2：**煎制处方**；
  C3：**非煎制处方**；
  C4：**药品**；
  C5：**快递信息**（C2、C3可以互换）。

【问题3】（3分）简要解释用例之间的`include`、`extend`和`generalize`关系的内涵。

- `include`：是一种依赖关系，加了版型<>，两个以上用例有共同功能，可分解到单独用例，其中这个提取出来的公共用例称为抽象用例，形成包含依赖；
  执行基本用例时，每次都必须调用被包含的用例。
  `extend`：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种事情，可以断定将这个用例分为一个主用例和一个或多个辅用例进行描述可能更加清晰。
  `generalize` 泛化关系：当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1和问题2，将解答填入答题纸的对应栏内。

【说明】
凸多边形是指多边形的任意两点的连线均落在多边形的边界或者内部。相邻的点连线落在多边形边上，称为边，不相邻的点连线落在多边形内部。称为弦。假设任意两点连线上均有权重，凸多边形最优三帮剂分问题定义为：求将凸多边形划分为不相交的三角形集合，且各三角形权重之和最小的剖分方案。每个三角形的权重为三条边权重之和。假设$N$个点的凸多边形点编号为$V_1, V_2,..., V_N$，若在$V_K$处将原凸多边形划分为一个三角$V_1V_kV_N$，两个子多边形$V_1, V_2, ...,V_k$和$V_k, V_{k+1}, ..., V_N$，得到一个最优的剖分方案，则该最优剖分方案应该包含这两个子凸边形的最优剖分方案。用`m[i][j]`表示带你$V_{i-1},V_i,...,V_j$构成的凸多边形的最优剖分方案的权重，`S[i][j]`记录剖分该凸多边形的$k$值。则
$$
m[i][j]=\left\{\begin{array}{ll}
0 & \text {i ≥ j }\\
\min_{i ≤ k < j} \{m[i][k]+m[k+1][j]+W(V_{i-1}V_kV_j)\} & \text {i < j} \\
\end{array}\right.
$$
其中：$W_{j, i-1}$分别为该三角形三条边的权重。求解凸多边形的最优剖分方案，即求解最小剖分的权重及对应的三角形集。

【C代码】

```c
#include <stdio.h>

#define N 6
//凸多边形规模
int m[N+1][N+1];  //m[i][j]表示多边形Vi-1到Vj最优三角形部分的值
int S[N+1][N+1];  //S[il[j]记录多边形Vi-1最优三角部分的k值
int W[N+1][N+1];  //凸多边形的织重矩阵，在main函数中输入
/* 三角形的权重a，b，C，三角形的顶点下标*/
int get_triangle_weight(int a, int b, int c) {
    return w[a][b]+w[b][c]+w[c][a];
}

/* 求解最化值 */
void triangle partition() {
    int i, r, k, j;
    int temp;
    /* 初始化 */
    for(i=1; i<=N; i++) {
        m[i][i]=0;
    }
    /* 自底向上计算m, S */
    for(r=2; __(1)__; r++) {  /*r为子问题规模*/ //r<=N
        for(i=1; k<=N-r+1; i++) {
            __(2)__;  //int j=i+r-1
            m[i][j]= m[i][j]+m[i+l][j]+get_triangle_weight(i-1,i,j); /* k=j */
            S[i][j]=i;
            for(k=j+1; k<j; k++) {  /*计算m[i][j]的最小代价 */
                temp = m[i][k]+m[k+1][j]+get_triangle_weight(i-1, k, j);
                if(__(3)__) {  /* 判断是否最小值 */ //temp
                    m[i][j] = temp;
                    s[i][j] = k;
                }
            }
        }
    }
}

/* 输出部分的三角形 i，j，凸多边形的起始点下标 */
void print triangle(int i, int j) {
    if(i==j) return;
    print_triangle(i,s[i][j]);
    print_triangle((4));  //s[i][j]+1, j
    print("v%d--V%d--V%d\n", i-1, s[i][j], j);
}
```

【问题1】（8分）根据说明和C代码，填充C代码中的空（1）～（4）。

- （1）**`r`**
  （2）**`int j=i+r-1 `**
  （3）**`temp`**
  （4）**`s[i][j]+1, j`**

【问题2】（7分）根据说明和C代码，该算法采用的设计策略为（5），算法的时间复杂度为（6），空间复杂度为（7）（用O表示）。

- （5）**动态规划法**
  （6）$O(n^3)$
  （7）$O(n^2)$

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。
【说明】
层叠买单是留口风格的软件系统中经常采用的一种系统功能组织方式。层叠菜单（如到5-1示例）中包含的可能是一个菜单项（直接对应某个功能），也可能是一个子菜单。现采用组合（Composite）设计模式实现层叠菜单，得到如图5-2所示的类图。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2021s-5-1.png)

【C++代码】

```c++
#include <list>
#include <iostream>
#include <string>
using namespace std;

class MenuComponent{
__(1)__:
    string name;
public:
    void printMenu() { cout << name; }
    __(2)__;
    virtual void removeMenuElement(MenuComponent *element) = 0;
    __(3)__;
};

class MenuItem : public MenuComponent {
public:
    MenuItem(string name) { this->name=name; }
    void addMenuElement(MenuComponent *element) { return; }
    void removeMenuElement(MenuComponent *element) { return; }
    list<MenuComponent*>* getElement() { return NULL; }
};

class Menu:public MenuComponent {
private:
    __(4)__;
public:
    Menu(string name) { this->name=name; }
    void addMenuElement(MenuComponent *element) { elementlist.push_back(element); }
    void removeMenuElement(MenuComponent *element) { elementList.remove(element); }
    list<MenuComponent*>* getElement() { return &elementList; }
};

int main() {
    MenuComponent *mainMenu = new Menu("Insert");
    MenuComponent *subMenu = new Menu("Chart");
    MenuComponent *element = new Menu("On This Sheet");
    __(5)__;
    subMenu->addMenuElement(element);
    return 0;
}
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`protected`**
  （2）**`virtual void addMenuElement(MenuComponent *element) = 0`**
  （3）**`virtual list* getElement() =0`**
  （4）**`list elementList`**
  （5）**`mainMenu->addMenuElement(subMenu)`**

------

## 2020年下半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某工厂制造企业为了开发软件智能检测以有双握升检测效率，节约人力资源，该系统的主要功能是:
（1）基础信息管理。管理员对检测标准和检测规则等基础信息设置。
（2）检测模型部署。管理员对常用机器学习方法建立的检测模型分布。
（3）图像采集。实时将检测多样的产的行建分存诸，包括产品结构，生产时间，图像后亏广品图像。
（4）缺陷检测。根据检测模型和检测质量T松图像采集所收到的产品检测信息中所有图像进行恼测或所有图像检测合格。着一个产品出现一张图像检测不合格，就表示该产品不合格，对不合格产品，其检测结果包括，产品型号和不合格类型。
（5）质量检测。根据监控规则对产品质量进行监控将检测情况展示给检测业务员，若满足条件。向检测业务员发送质量检测，质量检测是发起远程控制部分，检测设备发送控制指令进行处理。
（6）模型监控。在系统中部署的模型、产品的检测信息结合基础信息进行监测分析，将模型运行情况发给监控人员。
现采用结构化方法对智能检测系统，进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-1-1.png)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-1-2.png)

【问题1】（4分）使用说明中的语句对图1-1中的实体E1～E4的名称。

- **E1：检测设备**；
  **E2：管理员**；
  **E3：检测业务员**；
  **E4：监控人员**。

  本问题考查的是上下文DFD，要求确定外部实体。顶层DFD（上下文数据沉图）建模用于确定系统边界以及系统的输入输出数据，待开发软件系统被看作一个加工，为系统提供输入数据以及接受系统输出数据的是外部实体，外部实体和加工之间的输入输出即为数据流。数据流或者由具体的数据属性构成，或者是由其他数据流构成的组合数据流，用子高层数据流图中。在题干中待开发系统“智能缺陷检测系统”作为唯一加工，为这一加工提供输入数据流或者接收其输出数据流的外部实体，涉及软件之外的人员有管理员、检测业务员和监控人员，还有本系统需收发信息的外部检测设备。再根据描述相关信息进行对应，对照图1-1，即可确定E1为“检测设备”实体，E2为“管理员”实体，E3为“检测业务员”实体，E4为“监控人员”实体。

【问题2】（3分）使用说明中的语句对图1-2中的数据存储D1～D3的名称。

- **D1：检测模型**；
  **D2：检测信息**；
  **D3：基础信息**。

  本问题要求确定图1-2 0层数据流图中的数据存储和缺失的数据流及其起点和终点。0层DFD是将上下文DFD中的加工分解成多个加工，识别每个加工的输入数据流以及经过加工变换后的输出数据流。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。
  题干中将数据存储建模在0层DFD中。对照图1-2 中已经给出的信息，要确定数据存储，可以重点分析说明中与数据存储有关的描述。说明（2） 中“管理员对采用机器学习方法建立的检测模型进行部署”，图1-2中加工“模型部署”向DI写入新检测模型信息，由此可知DI为“检测模型”:再由说明（4）中“实时接收生产线上检测设备拍摄的产品待检信息进行存储”“设置检测结果信息”，说明（6）中“对系统中部署的模型、产品的检测信息结合基础信息进行监测分析”等信息，可知加工“图像采集”需要向D2中写入新待检信息、加工“缺陷检测”需要向D2中更新检测结果信息、加工“模型检测”需要从D2读出检测信息，由此可知D2为“检测信息”。说明（1）中“管理员对检测质量标准和监控规则等基础信息进行设置”可知加工“基础信息管理”向D3中写入基础信息，基础信息中包括质量标准，加工“缺陷检测”从D3读出质量标准，由此可知D3 为“基础信息”。
  补充缺失数据流时，注意在建模0层DFD时，加工和数据流的正确使用，以及保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。对照图1-1和图1-2的输入、输出数据流，缺少了起点外部实体E3到加工的数据流——“ 远程控制命令”，说明（5）中，“检测业务员发起远程控制命令，系统给检测设备发送控制指令进行处理”，可知此数据流终点为P5 （质量监控）。
  再考查题干中的说明判定是否缺失内部的数据流，不难发现图1-2中，缺少说明（5）中的输入数据流，“根据监控规则对产品质量进行监控，将检测情况展示”说明加工“质量监控”需要D3“基础信息”中监控规则，产品信息来源于对产品图像的D2“检测信息”；没有把说明（3）加工“图像采集”相关输出的数据流完整给出，缺少“产品待检信息进行“缺陷检测”，即P2为起点、P3为终点的“待检信息”；说明（6）根据描述“对系统中部署的模型、产品的检测信息结合基础信息进行监测分析”可知需要从D3中读取“基础信息”。

【问题3】（5分）根据注明和图中术语，补齐图1-2中缺失的数据及起点和终点。

- |    数据流    |       起点       |      终点      |
  | :----------: | :--------------: | :------------: |
  |   待检信息   |  P2 或 图像采集  | P3 或 缺陷检测 |
  |   检测信息   |  D2 或 检测信息  | P5 或 质量监控 |
  |   基础信息   |  D3 或 基础信息  | P5 或 质量监控 |
  |   监控规则   |  D3 或 基础信息  | P6 或 模型监控 |
  | 远程控制命令 | E3 或 检测业务员 | P5 或 质量监控 |

  本问题要求确定图1-2 0层数据流图中的数据存储和缺失的数据流及其起点和终点。0层DFD是将上下文DFD中的加工分解成多个加工，识别每个加工的输入数据流以及经过加工变换后的输出数据流。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。
  题干中将数据存储建模在0层DFD中。对照图1-2 中已经给出的信息，要确定数据存储，可以重点分析说明中与数据存储有关的描述。说明（2） 中“管理员对采用机器学习方法建立的检测模型进行部署”，图1-2中加工“模型部署”向DI写入新检测模型信息，由此可知DI为“检测模型”；再由说明（4）中“实时接收生产线上检测设备拍摄的产品待检信息进行存储”、“设置检测结果信息”，说明（6）中“对系统中部署的模型、产品的检测信息结合基础信息进行监测分析”等信息，可知加工“图像采集”需要向D2中写入新待检信息、加工“缺陷检测”需要向D2中更新检测结果信息、加工“模型检测”需要从D2读出检测信息，由此可知D2为“检测信息”。说明（1）中“管理员对检测质量标准和监控规则等基础信息进行设置”可知加工“基础信息管理”向D3中写入基础信息，基础信息中包括质量标准，加工“缺陷检测”从D3读出质量标准，由此可知D3 为“基础信息”。
  补充缺失数据流时，注意在建模0层DFD时，加工和数据流的正确使用，以及保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。对照图1-1和图1-2的输入、输出数据流，缺少了起点外部实体E3到加工的数据流——“ 远程控制命令”，说明（5）中，“检测业务员发起远程控制命令，系统给检测设备发送控制指令进行处理”，可知此数据流终点为P5 （质量监控）。再考查题干中的说明判定是否缺失内部的数据流，不难发现图1-2中，缺少说明（5）中的输入数据流，“根据监控规则对产品质量进行监控，将检测情况展示”说明加工“质量监控”需要D3“基础信息”中监控规则，产品信息来源于对产品图像的D2“检测信息”；没有把说明（3）加工“图像采集”相关输出的数据流完整给出，缺少“产品待检信息进行“缺陷检测”，即P2为起点、P3为终点的“待检信息”；说明（6）根据描述“对系统中部署的模型、产品的检测信息结合基础信息进行监测分析”可知需要从D3中读取“基础信息”。

【问题4】（3分）根据说明，采用结构化语言对“缺陷检测”的加工逻辑进行描述。

- ```
  检测产品的所有图像
  IF全部合格
  THEN设置检测结果信息为合格
  ELSE设置检测结果信息为不合格类型
  ENDIF
  给检测设备发送检测结果
  ```

  本问题要求采用结构化语言描述“缺陷检测”的加工逻辑。常用的加工逻辑描述方法有结构化语言、判定表和判定树3种。
  结构化语言（如结构化英语）是一种介于自然语言和形式化语言之间的半形式化语言，是自然语言的一个受限子集，没有严格的语法，其结构通常可分为内层和外层。外层有严格的语法，内层的语法比较灵活，可以接近于自然语言的描述。
  （1）外层。用来描述控制结构，采用顺序、选择和重复3种基本结构。
  ①顺序结构。一组祈使语句、选择语句、重复语句的顺序排列。祈使语句是指至少包含一个动词及一个名词，指出要执行的动作及接受动作的对象。
  ②选择结构。一般用IF-THEN-ELSE-ENDIF、CASE-OF-ENDCASE 等关键词。
  ③重复结构。一般用DO-WHILE-ENDDO、REPEAT-UNTIL等关键词。
  （2）内层。一般采用祈使语句的自然语言短语，使用数据字典中的名词和有限的自定义词，其动词含义要具体，尽量不用形容词和副词来修饰，还可使用一些简单的算法运算和逻辑运算符号。
  缺陷检测相关描述中，根据检测模型和检测质量标准对图像采集接收到的产品待检信息中所有图像进行检测。根据产品是否合格进行不同设置，最后，给检测设备发送检测结果。
  因此，首先是对所有图像进行检测；然后根据所有图像检测合格与否，设置合格状态与不合格类型；最后，给检测设备发送检测结果。根据是否合格采用选择结构，选择结构可选择IF-THEN-ELSE-ENDIF，也可以抽象出CASE情况，使用CASE-OF-ENDCASE。

### 试题二（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
M集团拥有多个分公司，为了方便集团公司对各个分公司职员进行有效管理，集团公司决定构建一个信息平台以满足公司各项业务管理需求。
【需求分析】
（1）分公司关系模式需要记录的信息包括公司编号、名称、经理号、可联系地址和电话。分公司编号唯一标记分公司关系模式中的每一个元组，每个分公司各有一名经理，负责分公司的管理工作，每个分公司设立仅为本分公司服务的多个业务部，业务部包括:研发部、财务部、采购部、交易部等。
（2）业务部关系模式需要记录的信息包括业务部的编号、名称、地址、电话和分公司编号，业务部编号唯一标记分公司关系模式中的每一个元素，每个业务部各有一名主管负责业务部的管理工作，每个业务部有多名职员，每个职员只能来源于一个业务部。
（3）职员关系模式需要记录的信息包括职员号、姓名、所属业务部编号、岗位、电话、家庭成员姓名和成员关系。其中职员号唯一标记职员关系，岗位包括:经理、主管、研发员、业务员等。

【关系模式】
分公司（分公司编号、名称、（a）、联系地址）
业务部（业务部编号、名称、（b）、电话）
职员（职员号、姓名、岗位、（c）、电话、家庭成员姓名、关系）

【概念模式设计】

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-2-1.png)

【问题1】（4分）根据问题描述，补充4个联系，完善图2-1的实体联系图，联系名可用联系1、联系2、联系3和联系4代替，联系的类型为`1∶1`、`1 :n`和`m:n`(或`1:1`、`1:*`和`*:*`）。

- 完善后的实体联系图如下所示（所补充的联系和类型如虚线所示）。
  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-2-2.png)

  需要补充的联系如下：
  根据题意“每个分公司只有一名经理，负责该分公司的管理工作”，所以**分公司和经理之间有一个“管理”联系，联系类型为`1:1`**。
  根据题意“每个分公司设立仅为本分公司服务的多个业务部”，所以**分公司和业务部之间的“组成”联系的类型为`1:*`**。
  根据题意“每个业务部只有一名主管，只负责管理本部门的工作”，所以**业务部和主管之间有一个“主管”联系，联系类型为`1:1`**。
  根据题意“每个业务部有多名职员，每名职员只能隶属于一个业务部”，所以**业务部和职员之间有一个“所属”联系，联系类型为`1:*`**。

【问题2】（3分）根据题意将以上关系模式中的空（a）～（c）的属性补充完整，并填入对应位置。

- （a）**经理号，电话**
  （b）**地址，分公司编号，主管号**
  （c）**所属业务部编号**

  根据需求分析1“分公司关系模式需要记录的信息包括分公司编号、名称、经理号、联系地址和电话”，所以空（a）应填入“经理号，电话”。根据需求分析2“业务部关系模式需要记录的信息包括业务部编号、名称、主管号、电话和分公司编号”，所以空（b）应为“主管号，分公司编号”。根据需求分析3“职员关系模式需要记录的信息包括职员号、姓名、所属业务部编号、岗位、电话、家庭成员姓名和成员关系，所以空（c）应为“所属业务部编号”。

【问题3】（4分）（1）分析分公司关系模式的主建和外键；（2）分析业务部关系模式的主建和外键。

- （1）**主键：分公司编号；外键：经理号**。
  （2）**主键：业务部编号；外键：主管号，分公司编号**。

  根据需求分析1中所述“分公司编号唯一标识分公司关系模式中的每一个元组”，分公司关系的主键为分公司编号。由于分公司关系中的“经理号”需要参照职工关系的职工号，故分公司关系的外键为经理号。
  根据需求分析2中所述“业务部编号唯一标识业务部关系模式中的每一个元组”，故业务部关系的主键为业务部编号。由于业务部关系中的“主管号”需要参照职工关系的职工号，业务部关系中的“分公司编号”需要参照分公司关系的分公司编号，故业务部关系的外键为主管号，分公司编号。

【问题4】（4分）在职员关系模式中，假设每个职员有多名家庭成员，那么职员关系模式存在什么问题？应如何解决？

- ①**存在冗余**；
  ②**将职员关系模式分解**；
  ③**分解为职员1（职员号，姓名，岗位，所属业务部号，电话）；职员2（职员号，家庭成员姓名，成员关系）**。

  存在冗余问题。例如，假设职员关系如表2-1所示，从表2-1可以看出，若1001职员有4名家庭成员，那么该职员的“职员号、姓名、所属业务部号、岗位、电话”信息重复了3次。
  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-2-3.jpg)

  解决办法是将职员关系模式分解，分解后的模式为：职员1（职员号，姓名，岗位，所属业务部号，电话），职员2（职员号，家庭成员姓名，成员关系）。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某房产公司，欲开发—个房产信息管理系统，其主要功能描述如下：
（1）公司销售的房产，分为住宅和公寓两类。针对房产，系统存储房产证明，地址，建造年份，建造面积，销售报价，房产照片以及销售状态（在售，售出，停售）等信息。对于公寓，还需存储是否有等信息。
（2）公司雇佣了多名房产经纪，负责销售房产，系统中需要存储房产经纪的基本信息，包括：姓名，家庭住址，联系电话，房产的起止时间等等。一套房产同一时间仅由一名房产经纪负责销售，系统中记录房产经纪负责房产的起始时间和终止时间。
（3）系统用户包括房产经纪和系统管理员，用户需经过系统身份验证之后，才能登录系统。房产经纪登录系统之后，可以录入负责销售的房产信息。但需要经过系统管理员的审批授权。
（4）系统管理员可以从系统中导出所有房产的信息列表，系统管理员定期将信息和销售的房产，进行归纳，若公司确定不再销售某套房产，系统管理员将房产信息从系统中删除。现采用面向对象方法开发该系统得到如图3-1所示的图例和3-2所示的图。

【问题1】（7分）
（1）根据证明中描述，分别给图3-1中A1到A2所对应的名称以及U1到U3所对应的用例名称。
（2）根据证明中描述，分别给图3-1中（a）和（b）用例之间的关系。

- **A1：房产经纪**
  **A2：系统管理员**
  **U1：审批授权**
  **U2：修改房产信息**
  **U3：删除房产信息**
  （a）**include**
  （b）**extend**

  本问题给出的应用场景是一个房产信息管理系统。本问题要求补充用例图。用例图展现了一组用例、参与者以及它们之间的关系。用例建模是按照业务事件、谁发起事件，以及系统如何响应事件建模系统功能的过程。
  参与者表示需要与系统交互以交换信息的任何事物。参与者可以是一个用户，可以是外部系统的一个角色，也可以是一个人。从题目的说明中可以很容易发现，该系统中有两类与系统交互的角色：房产经纪（Agent）和系统管理员（Manager）。 根据说明描述的每个角色所参与的功能，可以判断出：A1对应的参与者是房产经纪、A2对应的参与者是系统管理员。
  用例是一组相关行为的自动的和手动的步骤序列，其目的是完成单个业务任务。下面需要确定与参与者A1（房产经纪）相关联的用例。根据说明可知，Ai参与或激发的用例包括：录入、查询、修改房产信息等，所以用例U2对应的用例应该是“修改房产信息”。A2参与或激发的用例包括：审批授权、导出房产报表、归档房产信息以及删除房产信息。房产经纪在修改房产信息时，需要经过系统管理员的审批授权，所以U1对应的用例应该是“审批授权”，U3对应的用例就是“删除房产信息”。
  对于用例U1和U2之间的关系，“审批授权”是完成“修改房产信息”的不可缺少的步骤，适用于包含关系（include）。
  对于用例U3和用例“归档”，“删除房产信息（停售房产）”是“归档”业务中一个独立且可选的动作，适用于扩展关系（extend）。

【问题2】（6分）根据证明中描述，分别给图3-2中C1～C6所对应的类名称。

- **C1：Property 或房产**
  **C2：House 或住宅**
  **C3：Cando 或公寓**（C2和C3可互换）
  **C4：User 或用户**
  **C5：Manager 或管理员**
  **C6：Agent 或房产经纪**

  本问题要求将图3-2所示的类图补充完整。首先观察该类图，发现在图中存在两个继承结构： C1-C2-C3、C4-C5-C6。 从题目的说明中，可以找到明显的“一般-特殊”关系的表述：“公司销售的房产（ Property ）分为住宅（ House）和公寓（Cando） 两类”和“系统用户（User） 包括房产经纪和系统管理员（Manager）"。用户通过房产信息管理系统维护房产信息，所以房产对应继承结构C1-C2-C3；用户对应继承结构C4-C5-C6。因此，类C1对应“房产”、类C2对应“住宅”或“公寓”、类C3对应“公寓”或“住宅”、类C4对应“用户”、类C5对应“管理员”、类C6对应“房产经纪”。

【问题3】（2分）图3-2中的类`AgentList`是一个关联类，用来进—步表达类C1和C6之间的关系。根据说明中的描述，给出类`AgentList`的主要属性。

- **`AgentList`的主要属性：房产经纪负责该房产的起始时间、结束时间**。

  关联类是表达类与类之间关系的一种形式。本问题中，关联类`AgentList`用于表达类“房产”和类“房产经纪”之间的关系，以明确表达“一套房产同一时段仅由一名房产经纪负责销售”这一要求。因此`AgentList`中包含的主要属性应包括房产经纪负责该房产的起始时间、结束时间。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
希尔排序算法又称最小增量排序算法，其基本思想是：
步骤1：构造一个步长序列`delta1, delta2, ..., deltak`，其中`delta1=n/2`，后面的每个`delta`是前一个的`1/2`，`deltak=1`；
步骤2：根据步长序列、进行`k`趟排序；
步骤3：对第`i`趟排序，根据对应的步长`delta`，将等步长位置元素分组，对同一组内元素在原位置上进行直接插入排序。

【C代码】
常量和变量说明：`data`是待排序数组，数组中的元素个数为`n`，待排序数据记录在`data[0], data[1], ..., data[n-1]`中，`delta`是步长数组。

```c
#include <malloc.h>

void shellsort(int datal], int n) {
    int *delta, k, i, t, dk, j;
    k = n;
    delta = (int *) malloc(sizeof(int)*(n/2));
    if(i = 0) {
        do {
            __(1)__;
            delta[i++] = k;
        } while(__(2)__);
    }
    i = 0;
    while((dk = delta[i]) > 0) {
        for(k = deltali]; k < n; ++k) {
            if(__(3)__) {
                t = data[k];
                for(j = k-dk; j>=0 && t<data[j]; j-=dk) {
                    data[j + dk] = data[j];
                }  /* for */
                __(4)__; //data[j+dk]=t;
            }  /* if */
        ++i;
    }  /* while */
}
```

【问题1】（8分）根据说明和`C`代码，填充`C`代码中的空（1）～（4）。

- 【问题1】
  （1）**`k=k/2`** 或等价形式
  （2）**`k>1`**
  （3）**`data[k]<data[k-dt]`**
  （4）**`data[j+dk]=t`**

  本问题要求考生熟悉常用的排序算法和查找算法。
  希尔排序是一种经典的、高效的插入排序算法。在该算法中，给定步长序列作为划分待排序子序列的依据。每趟排序时，将待排序序列根据步长`delta`分成多个不连续的子序列，对每个子序列采用直接插入排序算法。如对某数组A—`(a1,a2,a3,...,a10)`。在某趟排序时，若`delta=3`，则将`A`分成三个子序列，`A1=(a1, a4, a7, a10)`，`A2=(a2, a5, a8)`，`A3=(a3, a6, a9)`，然后分别在原位置上对A1、A2和A3进行直接插入排序处理。最后一趟排序中，`delta=1`，这样可以确保输出序列是有序的。`delta`序列是希尔排序算法在具体实现的过程中定义的，题干中已经给出，`delta1=n/2`，后面的每个`delta`是前一个的1/2，最后的`deltak=1`。题中C代码的`do...while`循环给delta序列赋值，根据题干，很容易得到空（1）为`k=k/2`，空（2）填`k>1`。接下来的代码段是根据`delta`值进行每一趟的排序， 每趟排序是对不连续的每个子序列进行插入排序，因此，空（3）填`data[k]<data[k-dk]`，即判断是否需要进行插入，空（4）填`data[j + dk]=t`，即确定了待插入的元素的位置。

【问题2】（4分）根据说明和C代码，求该算法的时间复杂度（5）与$O(n^2)$的关系（小于、等于或大于），该算法是否稳定（6）（是或否）。

- （5）**小于**
  （6）**否**

  在理论上分析希尔排序算法的时间复杂度是一个复杂的问题，与数据分布和增量序列都有关系。大量的实验结果说明，希尔排序算法比直接插入排序算法的效率更高，直接插入排序算法的时间复杂度为O(n2)，而希尔排序算法的时间复杂度大约为O(n1.3)。
  根据算法思想和操作步骤，在排序过程中，每次移动元素时会跳过中间的若干个元素，不能保证关键字相同的两个元素其相对位序不改变，因此该算法是不稳定的。

【问题3】（3分）对数组（15、9、7、8、20、-1、4）用希尔排序方法进行排序，经过第—趟排序后得到的数组为（7）。

- 
  （7）**(4, 9, -1, 8, 20, 7, 15)**。

  对数组A=(15, 9, 7, 8, 20, -1, 4), n=7，根据题干说明delta1=n/2=3, A1=(15, 8, 4)，A2=(9, 20)和A3=(7, -1)，对每个子序列排序后得到，A1=(4, 8, 15)，A2=(9, 20)和A3=(-1, 7)，还原到原数组得到第一趟排序后的数组A=(4, 9, -1, 8, 20, 7, 15)。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入(n)处的字句写在答题纸的对应栏内。

【说明】
在线支付是电子商务的一个重要环节，不同的电子商务平台提供了不同的支付接口。现在需要整合不同电子商务平台的支付接口，使得客户在不同平台上购物时，不需要关心具体的支付接口。拟采用中介者（Mediator）设计模式来实现该需求，所设计的类图如图5-1所示。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2020x-5-1.png)

【C++代码】

```c++
#include "cstddef"
#include "iostream"

using namespace std;
class WebService;
class WebServiceMediator {
public:
    __(1)__ = 0;
    virtual void SetAmazon(WebService *amazon) = 0:
    virtual void SetEbay(WebService *ebay) = 0;
};

class WebService {
protected:
    __(2)__ *mediator;
public:
    virtual void setServiceMediator(WebServiceMediator *mediator) = 0;
    __(3)__ = 0;
    virtual void search(double money) = 0;
};

class ConcreteServiceMediator : public WebServiceMediator {
private:
    WebService *amazon;
    WebService *ebay;
public:
    ConcreteServiceMediator() : amazon(NULL), ebay(NULL) {}
    void SetAmazon(WebService *amazon) { this->amazon = amazon; }
    void SetEbay(WebService *ebay) {
        this->ebay = ebay;
    }
    void buy(double money, WebService *service) {
        if(service == amazon) amazon->search(money); 
        else ebay->search(money);
    }
};

class Amazon : public WebService {
public:
    void SetMediator(WebServiceMediator *mediator) { this->mediator = mediator; }
    void buyService(double money) {
        __(4)__;
    }
    void search(double money) {
        cout << "Amazon receive:" << money << endl;
    }
};

class Ebay : public WebService {
public:
    void setMediator(WebServiceMediator *mediator) { this->mediator = mediator; }
    void buyService(double money) { __(5)__; }
    void search(double money) {
        cout << "Ebay receive:" << money << endl;
    }
};
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`virtual void buy(double money, WebService *service)`**
  （2）**`WebServiceMediator`**
  （3）**`virtual void buyService(double money)`**
  （4）**`mediator->buy(money, this)`**
  （5）**`mediator->buy(money, this)`**

------

## 2019年下半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某公司欲开发—款二手车物流系统，以有效提升物流成交效率。该系统的主要功能是：
（1）订单管理：系统抓取线索，将车辆交易系统的交易信息抓取为线索。帮买顾问看到有买车线索后，会打电话询问买家是否需要物流，若需要，帮买顾问就将这个线索发起为订单并在系统中存储，然后系统帮助买家寻找物流商进行承运。
（2）路线管理：帮买顾问对物流商的路线进行管理，存储的路线信息包括路线类型、物流商、起止地点。路线分为三种，即固定路线、包车路线、竞拍体系，其中固定路线和包车路线是合约制。包车路线的发车时间由公司自行管理，是订单的首选途径。
（3）合约管理：帮买顾问根据公司与物流商确定的合约，对合约内容进行设置，合约信息包括物流商信息、路线起止城市、价格、有效期等。
（4）寻找物流商：系统根据订单的类型（保卖车、全国购和普通二手车）、起止城市，需要的服务模式（买家接、送到买家等）进行自动派发或以竞拍体系方式选择合适的物流商。即：有新订单时，若为保卖车或全国购，则直接分配到竞拍体系中；否则，若符合固定路线和/或包车路线，系统自动分配给合约物流商，若不符合固定路线和包车路线，系统将订单信息分配到竞拍体系中。竞拍体系接收到订单后，将订单信息推送给有相关路线的物流商，物流商对订单进行竞拍出价，最优报价的物流商中标。最后，给承运的物流商发送物流消息，更新订单的物流信息，给车辆交易系统发送物流信息。
（5）物流商注册：物流商账号的注册开通。现采用结构化方法对二手车物流系统进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-1-1.png)

【问题1】（3分）使用说明中的词语，给出图1-1中的实体E1～E3的名称。

- **E1：帮买顾问**；
  **E2：车辆交易系统**；
  **E3：物流商**。

  本题考查采用结构化方法进行软件系统的分析与设计，主要考查利用数据流图（DFD）进行需求分析和建模。DFD是面向数据流建模的工具，它将系统建模成输入、加工（处理）、输出的模型，即流入软件的数据对象，经由加工的转换，最后以结果数据对象的形式流出软件，并采用自顶向下分层建模进行逐层细化。建立数据字典，对数据流图中的每条数据流、存储、加工和组成数据流或存储的数据项、加工的逻辑再进一步说明。
  顶层DFD（上下文数据流图）建模用于确定系统边界以及系统的输入输出数据，待开发软件系统被看作一个加工，为系统提供输入数据以及接收系统输出数据的是外部实体，外部实体和加工之间的输入输出即为数据流。数据流或者由具体的数据属性构成，或者是由其他数据流构成的组合数据流，用于高层数据流图中。将上下文DED中的加工分解成多个加工，识别每个加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。
  在建模分层DFD时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工。注意要在绘制下层数据流图时保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。
  题目题干描述清晰，易于分析，要求考生细心分析题目中所描述的内容。
  本问题考查的是上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统“二手车物流系统”作为唯一加工，为这一加工提供输入数据流或者接收其输出数据流的外部实体，涉及车辆交易系统、帮买顾问和物流商，再根据描述相关信息进行对应，对照图1-1，即可确定E1为“帮买顾问”实体，E2为“车辆交易系统”实体，E3为“物流商”实体。

【问题2】（5分）使用说明中的词语，给出图1-2中的数据存储D1～D5的名称。

- **D1：线索**；
  **D2：订单**；
  **D3：路线**；
  **D4：合约**；
  **D5：物流商**。
  - 本问题要求确定图1-20层数据流图中的数据存储。
  对照图1-2中己经给出的信息，重点分析说明中与数据存储有关的描述。说明（1）中“将车辆交易系统的交易信息抓取为线索”，可知加工“抓取线索”向存储中写入新线索信息，由此可知D1为“线索”；再由说明（1）中“帮买顾问就将这个线索发起为订单并在系统中存储”等信息，可知此加工需要向存储中写入新订单信息，由此可知D2为“订单”。说明（2）中“帮买顾问对物流商的路线进行管理，存储的路线信息”可知加工“路线管理”向D3中写入路线信息，由此可知D3为“路线”。说明（3）中合约管理“对合约内容进行设置”等，可知D4为“合约”。说明（5）中“选择合适的物流商”和说明（6）中“物流商账号的注册开通”，可知D5为“物流商”。

【问题3】（4分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |   数据流   |       起点       |        终点        |
  | :--------: | :--------------: | :----------------: |
  |  物流信息  | P5 或 寻找物流商 | E2 或 车辆交易系统 |
  | 新订单信息 | D2 或 订单信息表 |  P5 或 寻找物流商  |
  |  路线信息  | D3 或 路线信息表 |  P5 或 寻找物流商  |
  |  合约信息  | D4 或 合约信息表 |  P5 或 寻找物流商  |

  本问题要求补充缺失的数据流及其起点和终点。
  对照图1-1和图1-2的输入、输出数据流，缺少了从加工到外部实体E2的数据流——“物流信息”，说明（4）中，“最后，给承运的物流商发送物流消息”，可知此数据流起点为P5（寻找物流商），终点为E2 （车辆交易系统）。
  再考查题干中的说明判定是否缺失内部的数据流，不难发现图1-2中没有完整给出说明（4）加工“寻找物流商”相关的输入数据流。根据描述“根据订单的类型”可知需要从存储D2（订单）中获取数据；“若符合固定路线和/或包车路线，系统自动分配给合约物流商”说明需要获取存储D4（路线）和D3（合约）的信息进行判定然后进行分配。

【问题4】（3分）根据说明，采用结构化语言对“P5：寻找物流商”的加工逻辑进行描述。

- ```
  接收新订单
  IF是保卖车或全国购
  THEN执行竞拍体系，最优报价物流商中标
  ELSE
      IF订单路线有固定路线和/或包车路线
      THEN自动派发给物流商
      ELSE执行竞拍体系，最优报价物流商中标
      ENDIF
  ENDIF
  给物流商发送物流消息
  更新订单的物流信息
  给车辆交易系统发送物流信息
  ```

  本问题要求采用结构化语言描述“P5:寻找物流商”的加工逻辑。结构化语言（如结构化英语）是一种介于自然语言和形式化语言之间的半形式化语言,是自然语言的一个受限子集。结构化语言没有严格的语法，它的结构通常可分为内层和外层。外层有严格的语法，内层的语法比较灵活，可以接近于自然语言的描述。
  （1）外层。用来描述控制结构，采用顺序、选择和重复3种基本结构。
  ①顺序结构。一组祈使语句、选择语句、重复语句的顺序排列。祈使语句是指至少包含一个动词及一个名词，指出要执行的动作及接受动作的对象。
  ②选择结构。一般用IF-THEN-ELSE-ENDIF、CASE-OF-ENDCASE等关键词。
  ③重复结构。一般用DO-WHILE-ENDDCK、REPEAT-UNTIL等关键词。
  （2）内层。一般采用祈使语句的自然语言短语，使用数据字典中的名词和有限的自定义词，其动词含义要具体，尽量不用形容词和副词来修饰，还可使用一些简单的算法运算和逻辑运算符号。
  寻找物流商相关描述中，在有新订单时，明确在不同情况下执行不同行为，最后发送物流消息和更新订单内容。所以，首先是接收新订单；然后根据订单类型采用选择结构；再根据非保卖车或全国购的情况下，根据路线情况不同需执行不同行为，再嵌套一层选择结构；最后顺序发送物流消息和更新订单内容。选择结构可选择IF-THEN-ELSE-ENDIF，也可以抽象出CASE情况，使用CASE-OF-ENDCA5E。

### 试题二（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
公司拟开发新入职员工的技能培训管理系统以便使新员工快速胜任新岗位。
（1）部门信息包括：部门号、名称、部门负责人、电话等，部门号唯一标识部门关系中的每一个元组，一个部门有多个员工，但一名员工只属于一个部门，每个部门只有一名负责人，负责部门工作。
（2）员工信息包括员工号、姓名、部门号、岗位、基本工资、电话、家庭住址等，其中员工号是唯一标示员工关系中的每一个元组。岗位有新入职员工，培训师、部门负责人等不同岗位设置不同的基本工资，新入职员工要选择多门课程进行培训，并通过考试取得课程成绩，一名培训师可以讲授多门课程、—门课程可由多名培训师讲授。
（3）课程信息包括课程号，课程名称、学时等；其中课程号唯—标识课程关系的每一个元组。

【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图如图2-1所示。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-2-1.jpg)

【关系模式设计】
部门（部门号，部门名，部门负责人，电话）
员工（员工号，姓名，部门号，（d），电话，家庭住址）
课程（（e），课程名称，学时）
讲授（课程号，培训师，培训地点）培训（课程号，（f））

【问题1】（5分）（1）补充图2-1中的空（a）～（c）；（2）图2-1中是否存在缺失联系？若存在，则说明所缺失的联系和联系类型。

- （1）（a）**部门负责人**；（b）**培训师**；（c）**新入职员工**。
  （2）存在。图2-1中缺失一个部门和员工之间的“所属”联系，联系类型为`1:n`（或`1.*`）。

  本题考查数据库系统中实体联系模型（E-R模型）和关系模式设计方面的基础知识。
  根据题意“每个部门只有一名负责人，负责部门工作”，那么“负责”联系的两端 实体为部门和部门负责人，故空（a）应填写“部门负责人”。根据题意“一名培训师可以讲授多门课程，一门课程可以由多个培训师讲授”，那么“讲课”联系的两端实体为培训师和课程，故空（b）应填写“培训师”。根据题意“新入职员工至少要选择三门以上的课程进行培训，并通过考试取得课程的成绩”，那么“培训”联系的两端实体为新入职员工和课程，故空（c）应填写“新入职员工”。由于一个部门有多名员工，但一名员工只对应一个部门。故部门与员工之间的“所属”联系类型为`1:n`（或`1.*`）。根据上述分析，完善图2-1所示的实体联系图如图2-2所示。

  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-2-2.jpg)

【问题2】（3分）根据题意，将关系模式中的空（d）～（f）补充完整。

- （d）**岗位，基本工资**；（e）**课程号**；（f）**新入职员工，成绩**。

  根据题意员工信息包括：员工号、姓名、部门号、岗位、基本工资、电话、家庭住址。故员工关系模式中的空（d）应填写岗位，基本工资。根据题意课程信息包括：课程号、课程名称、学时，故课程关系中的空（e）应填写课程号。根据题意“新入职员工至少要选择三门以上的课程进行培训，并通过考试取得课程的成绩”，故培训关系的空（f）应填写新入职员工，成绩。

【问题3】（5分）（1）员工关系模式的主键为（g），外键为（h）；（2）讲授关系模式的主键为（i），外键为（j）。

- （1）（g）**员工号**；（h）**部门号**。
  （2）（i）**（课程号，培训师）**；（j）**课程号培训师**。

  （1）空（g）（h）分析：员工号唯一标识员工关系中的每一个元组，员工关系的主键为员工号。又因为部门号应参照部门关系的部门号，而部门号是部门关系的主键，故员工关系的外键为部门号。
  （2）空（i）（j）分析：因为（课程号，培训师）唯一确定讲授关系的每一个元组，所以讲授关系的主键为（课程号，培训师）。又因为课程号应参照课程关系的课程号，培训师应参照员工关系的员工号，故讲授关系存在两个外键分别为课程号和培训师。

【问题4】（2分）员工关系是否存在传递依赖？用100字以内的文字说明理由。

- **存在**。因为员工号一岗位、岗位一基本工资，根据Armstrong公理系统的传递律规则，员工关系**存在传递依赖“员工号—基本工资”**。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
某牙科诊所拟开发—套信息系统，用于管理病人的基本信息和就诊信息。诊所工作人员包括：医护人员（Dental Staff）、接待员（Receptionist）和办公人员（Office Staff）等。系统主要功能需求描述如下：
（1）记录病人基本信息（Maintain patient info）。初次就诊的病人，由接待员将病人基本信息录入系统。病人基本信息包括病人姓名、身份证号、出生日期、性别、首次就诊时间和最后一次就诊时间等。每位病人与其医保信息（Medical Insurance）关联。
（2）记录就诊信息（Record office visit info）。病人在诊所的每一次就诊，由接待员将就诊信息（Office Visit）录入系统。就诊信息包括就诊时间、就诊费用、支付代码、病人支付费用和医保支付费用等。3.记录治疗信息（Record dental procedure）。病人在就诊时，可能需要接受多项治疗，每项治疗（Procedure）可能由多位医护人员为其服务。治疗信息包括：治疗项目名称、治疗项目描述、治疗的牙齿和费用等。治疗信息由每位参与治疗的医护人员分别向系统中录入。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-3-1.png)

【问题1】（6分）根据说明中的描述，给出图3-1中A1～A3所对应的参与者名称和U1～U3所对应的用例名称。

- **A1：Receptionist 或接待人员**
  **A2：DentalStaff 或 医护人员**
  **A3：OfficeStaff 或 办公人员**
  **U1：Record office visit info 或 记录就诊信息**
  **U2：Maintain patient info 或 记录病人基本信息**
  **U3：Print invoices 或 打印发票**

  本题主要考查面向对象分析与设计的基本概念。在建模方面，本题仅涉及了UML的用例图和类图，根据需求说明将模型补充完整。题目较为简单，属于经典考题。本问题给出的应用场景是一个用于管理病人基本信息和就诊信息的牙科诊所信息系统。本问题要求补充用例图。用例图展现了一组用例、参与者以及它们之间的关系。用例建模是按照业务事件、谁发起事件，以及系统如何响应事件建模系统功能的过程。
  参与者表示需要与系统交互以交换信息的任何事物。参与者可以是一个用户，可以是外部系统的一个角色，也可以是一个人。从题目的说明中可以很容易地发现，该系统中有3类与系统交互的角色：医护人员、接待员和办公人员。根据说明所描述的每个角色所参与的功能，可以判断出：A1对应的参与者是接待人员、A2对应的参与者是医护人员、A3对应的参与者是办公人员。
  用例是一组相关行为的自动的和手动的步骤序列，其目的是完成单个业务任务。下面需要确定与参与者A1（接待人员）相关联的用例。根据说明可知，A1参与或激发的用例包括：记录病人基本信息和记录就诊记录，所以用例U1和U2分别对应“记录病人基本信息”和“记录就诊记录”。U3是与参与者A3（办公人员）相关联的用例。根据说明可知，A3参与或激发的用例包括：打印发票、更新支付状态和记录医护人员信息。显而易见，U3应该对应着用例“打印发票”。

【问题2】（5分）根据说明中的描述，给出图3-2中C1～C5所对应的类名。

- **C1：`Patientlnvoice`**
  **C2：`Insurancelnvoice`**
  **C3：`Invoice`**
  **C4：`Procedure`**
  **C5：`Office Visit`**

  本问题要求将图3-2所示的类图补充完整。
  首先观察该类图，发现在图中存在一个继承结构：C3为基类、C1和C2为派生类。而这3个类又分别与类Payment、Medical Insurance相关联，这两个类实现的都是与支付相关的功能。从说明中关于支付相关功能的描述可知，“发票分为两种：给医保机构的发票（Insurance Invoice）和给病人的发票（Patient Invoice)”，这是一种明显的“一般——特殊”关系，这种关系在面向对象中通常采用继承机制来描述。表达一般概念的实体作为基类，特殊概念的实体作为派生类。由此可以确定C3对应类`Invoice`。C1关联着类Patient，所以C1对应类`Patientlnvoice`，C2对应类`InsuranceInvoice`。C4、C5及其相关联的类，对应的是该系统维护就诊信息和治疗信息的功能。由说明可知，病人可以多次就诊；病人的每次就诊，可能包含多项治疗。这个需求由类`Patient`、C5及C4构成的关联结构表达。由此推断出，C5对应着类`OfficeVisit`，C4对应着类`Procedure`。

【问题3】（4分）根据说明中的描述，给出图3-2中类C4、C5、`Patient`和`Dental Staff`的必要属性。

- C4的属性：**治疗项目名称、治疗项目描述、治疗的牙齿、费用**。
  C5的属性：**就诊时间、就诊费用、支付代码、病人支付费用、医保支付费用**。
  `Patient`的属性：**病人姓名、身份证号、出生日期、性别、首次就诊时间、最后一次就诊时间**。
  `Dental Staff`的属性：**姓名、职位、身份证号、家庭住址、联系电话**。

  类的属性可以从说明的相关描述中寻找。本题中只需找出类的关键属性即可，实现阶段所需添加的属性不需要考虑。
  C4（`Procedure`）的属性描述在说明的第3条，包括：治疗项目名称、治疗项目描述、治疗的牙齿和费用。
  C5（`OfficeVisit`）的属性描述在说明的第2条，包括：就诊时间、就诊费用、支付代码、病人支付费用、医保支付费用。
  `Patient`的属性描述在说明的第1条，包括：病人姓名、身份证号、出生日期、性别、首次就诊时间、最后一次就诊时间。
  `DentalStaff`的属性描述在说明的第5条，包括：姓名、职位、身份证号、家庭住址、联系电话。

### 试题四（共15分）

阅读下列说明和`C`代码，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
0-1背包问题定义为：给定i个物品的价值`v[1...i]`、小重量`w[1...i]`和背包容量`T`，每个物品装到背包里或者不装到背包里。求最优的装包方案，使得所得到的价值最大。0-1背包问题具有最优子结构性质。定义`c[i][T]`为最优装包方案所获得的最大价值，则可得到如下所示的递归式。
$$
c[i][T]=\left\{\begin{array}{ll}
0 & \text { 若 } i=0 \text { 或 } T=0 \\
c[i-1][T] & \text { 若 } T<w[i] \\
\max (c[i-1][T-w[i]]+v[i], c[i-1][T]) & \text { 若 } i>0 \text { 且 } T \geqslant w[i]
\end{array}\right.
$$
【C代码】
常量和变量说明：`T`是背包容量，`v[]`是价值数组，`w[]`是重量数组，`c[i][j]`表示前i个物品在背包容量为j的情况下最优装包方案所能获得的最大价值。

```c
#include <stdio.h>
#include <math.h>

#define N 6
#define maxT 1000

int c[N][maxT] = {0};

int Memoized_Knapsack(int v[N], int w[N], int T) {
    int i;
    int j;
    for(i = 0; i < N; j++) {
        for(j = 0; j <= T; j++) {
            c[i][f] = -1;
        }
    }
    return Calculate_Max_Value(v, W, N-1, T);
}

int calculate_Max_Value(int v[N], int w[N], int i, int j) {
    int temp = 0;
    if(c[i][j] != -1) {
        __(1)__;
    }
    if(i == 0 || j == 0) {
        c[i][j] = 0;
    } else {
        c[i][j] = Calculate_Max_Value(v, w, i-1, j);
        if(__(2)__) {
            temp = __(3)__;
            if(c[i][j] < temp) {
                __(4)__;
            }
        }
    }
    return c[i][j];
}
```

【问题1】（8分）根据说明和C代码，填充C代码中的空（1）～（4）。

- （1）**`c[i][j]`**。
  （2）**`j>=w[i]`**。
  （3）**`Calculate_Max_Value(v, w, i-l, j-w[i])+v[i]`**。
  （4）**`c[i][j]=temp`**。
  - 本题考查算法设计策略和算法分析技术。
  此类题目要求考生认真阅读题目，理解题干中描述的问题和求解问题的算法思想。本题考查0-1背包问题，这是一个非常经典的计算问题，可以用动态规划法或者回溯法求解。这里考查考生对动态规划策略求解0-1背包问题的理解，题干己经给出最优子结构及其递归式。
  一般情况下，采用动态规划法求解最优化问题是构建递归式，然后自底向上迭代地求解，这里采用了自顶向下的递归求解方法，但是和传统的递归又不同。在求解问题的过程中，对第一次遇到的问题采用递归方法求解，把解存放到数组中，后面再次遇到该问题时，直接到数组中查询。
  `C`程序中己经说明`c[i][j]`表示前i个物品在背包容量为j的情况下最优装包方案所能获得的最大价值。开始时`c[i][j]`初始化为`-1`。`Calculate_Max_Value`函数用来计算`c[i][j]`的值。进入函数后，先判断`c[i][j]`的值是否为`-1`，如果不是，说明己经计算过，直接返回该值即可，因此空（1）填`c[i][j]`；如果是`-1`，那么需要递归计算。空（2）上面的语句计算了在前`i-1`项，容量为`j-w[i]`的背包问题值的最大价值，因此空（2）填入`w[i]<=j`，考虑在前`i-1`项，容量为`j-w[i]`的背包问题值的最大价值，比较两者的大小关系，因此空（3）和空（4）分别填入`Calculate_Max_Value(v, w, i-1, j-w[i])+v[i]`和`c[i][j]=temp`。

【问题2】（4分）根据说明和C代码，算法采用了（5）设计策略。在求解过程中，采用了（6）（自底向上或者自顶向下）的方式。

- （5）**动态规划**
  （6）**自顶向下**

  从题干分析和C代码来看，很容易知道这是一个动态规划算法，算法实现采用的是自顶向下的方法。

【问题3】（3分）若5项物品的价值数组和重量数组分别为`v[]={0, 1, 6, 18, 22, 28}`和`w[]= {0, 1, 2, 5, 6, 7}`背包容量为`T=11`，则获得的最大价值为（7）。

- （7）**40**

  根据题干和C代码，得到下列`c[i][j]`的值。
  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-4-1.jpg)

  从表中可知`c[5][11]=40`。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。

【说明】
某文件管理系统中定义了类`OfficeDoc`和`DocExplorer`。当类`OfficeDoc`发生变化时，类`DocExplorer`的所有对象都要更新其自身的状态。现采用观察者（Observer）设计模式来实现该需求，所设计的类图如图5-1所示。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-5-1.png)

【C++代码】

```c++
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

class Observer {
public:
    __(1)__;
};

class Subject {
protected:
    vector<__(2)__> myObs;
public:
    virtual void Attach(Observer *obs) { myObs.push_back(obs); }
    virtual void Detach(Observer *obs) {
        for(vector<Observer*>::iterator iter = myObs.begin(); iter != myObs.end(); iter++) {
            if(*iter == obs) { myObs.erase(iter); return; }
        }
    }
    virtual void Notify() {
        for(vector<Observer*>::iterator iter = myObs.begin(); iter != myObs.end(); iter++) {
            __(3)__;
        }        
    }
    virtual int getStatus() = 0;
    virtual void setStatus(int status) = 0;
};

class OfficeDoc : public Subject {
 private:
    string mySubjectName;
    int m_status;
public:
     OfficeDoc(string name) : mySubjectName(name), m_status(0) {}
     void setStatus(int status) { m_status = status; }
     int getStatus() { return m_status; }
};

class DocExplorer : public Observer {
private:
    string myObsName;
public:
    DocExplorer(string name, __(4)__ sub) : myObsName(name) { sub->__(5)__; }
    void update() { cout << "update observer:" << myObsName << endl; }
};
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`virtual void update() = 0`**
  （2）**`Observer *`**
  （3）**`(*iter)->update()`**
  （4）**`Subject*`**
  （5）**`Attach(this)`**

  本题考查设计模式中的观察者（Observer）模式的基本概念和应用。
  观察者模式的章图是，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者模式的结构图如图5-2所示。

  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019x-5-2.jpg)

  其中：
  `Subject`（目标）知道它的观察者，可以有任意多个观察者观察同一个目标：提供注册和删除观察者对象的接口。
  `Observer`（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。
  `ConcreteSubject`（具体目标）将有关状态存入各`ConcreteObserver`对象；当其状态发生改变时，向它的各个观察者发出通知。
  `ConcreteObserver`（具体观察者）维护一个指向`ConcreteSubject`对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现`Observer`的更新接口，以使自身状态与目标的状态保持一致。
  观察者模式适用于：
  当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。
  当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。
  当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。
  本题中的类`Subject`对应于图5-2中的`Subject`，类`OfficeDoc`对应`ConcreteSubject`，类`Observer`对应图5-2中的`Observer`，类`DocExplore`对应`ConcreteObserver`。`DocExplore`维护一个指向`OfficeDoc`对象的引用，当`OfficeDoc`的状态发生改变时，向`DocExplore`发出通知。
  第（1）空需要填写`Observer`中的核心方法，即在目标发生改变时通知观察者的更新接口。这个方法的原型可以在`Obsever`的子类`DocExplore`中找到：`void update()`。`update()`方法需要在子类中进行重置,这里采用了C++中的动态多态机制一一纯虚拟函数。所以第（1）空应填入`virtual void update()=0`。
  一个`Subject`可以有多个观察者，在`Subject`中需要提供增加和删除观察者的接口，即类中的`Attach`、`Detach`方法。这两个方法的主要操作对象就是类中的属性`myObs`。根据程序上下文推断，`myObs`表示的应该是观察者的集合，所以第（2）空应填入`Observer*`。
  第（3）空出现在`Subject`的方法`Notify`中，这个方法的功能是当目标发生变化时，通知所有与该目标关联的观察者，即调用每个观察者定义的`update`方法，所以第（3）空应填入`(*iter)->update()`。
  `DocExplore`是一个具体的观察者，它需要维护一个指向目标的对象，在这里实际上就是指向`OfficeDoc`的对象。观察者与目标的关联关系是通过`DocExplore`的构造函数实现的。在面向对象的继承机制中，通常倾向于用基类指针代替派生类指针，因此第（4）空应填入`Subject*`。
  观察者与目标的关联关系的建立需要调用`Subject`中的方法`Attach`，因此第（5）空应填入`Attach(this)`。

------

## 2019年上半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某学校欲开发一学生跟踪系统，以便更自动化、更全面地对学生在校情况（到课情况和健康状态等）进行管理和追踪，使家长能及时了解子女的到课情况和健康状态，并在有健康问题时及时与医护机构对接。该系统的主要功能是：
（1）采集学生状态。通过学生卡传感器，采集学生心率、体温(摄氏度)等健康指标及其所在位置等信息并记录。每张学生卡有唯一的标识（ID）与—个学生对应。
（2）健康状态告警。在学生健康状态出问题时，系统向班主任、家长和医护机构健康服务系统发出健康状态警告，由医护机构健康服务系统通知相关医生进行处理。
（3）到课检查。综合比对学生状态、课表以及所处校园场所之间的信息对学生到课情况进行判定。对旷课学生，向其家长和班主任发送旷课警告。
（4）汇总在校情况。定期汇总在校情况，并将报告发送给家长和班主任。
（5）家长注册。家长注册使用该系统，指定自己子女，存入家长信息，待审核。
（6）基础信息管理。学校管理人员对学生及其所用学生卡和班主任、课表（班级、上课时间及场所等）、校园场所（名称和所在位置区域）等基础信息进行管理；对家长注册申请进行审核，更新家长状态，将家长ID加入学生信息记录中使家长与其子女进行关联，向家长发送注册结果。一个学生至少有一个家长，可以有多个家长。课表信息包括班级、班主任、时间和位置等。现采用结构化方法对学生跟踪系统进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-1-1.jpg)

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-1-2.jpg)

【问题1】（5分）使用说明中的词语，给出图1-1中的实体E1～E5的名称。

- **E1：学生卡**
  **E2：管理人员**
  **E3：班主任**
  **E4：家长**
  **E5：医护机构健康服务系统**

  本题考查采用结构化方法进行软件系统的分析与设计，主要考查利用数据流图（DFD）进行分析和建模。
  DFD是面向数据流建模的工具，它将系统建模成输入、加工（处理）、输出的模型，即流入软件的数据对象、经由加工的转换、最后以结果数据对象的形式流出软件，并采用自顶向下分层建模进行逐层细化。顶层DFD（上下文数据流图）建模用于确定系统边界以及系统的输入输出数据，待开发软件系统被看作一个加工，为系统提供输入数据以及接受系统输出数据的是外部实体，外部实体和加工之间的输入输出即为数据流。数据流或者由具体的数据属性（也称为数据结构）构成，或者由其他数据流构成，即组合数据流，用于在高层数据流图中组合相似的数据流。将上下文DFD中的加工分解成多个加工，分别识别这些加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。
  在建模分层DFD时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工；要注意在绘制下层数据流图时保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。
  题目题干描述清晰，易于分析，要求考生细心分析题目说明中所描述的内容。本问题考查的是上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统名称“学生跟踪系统”作为唯一加工的名称，为这一加工提供输入数据流或者接收其输出数据流的外部实体，涉及学生卡、班主任、家长、医护机构健康服务系统和管理人员。需要注意的是，医生并不直接接收学生跟踪系统的信息，说明（2）中“由医护机构健康服务系统通知相关医生”是本系统的外部实体医护机构健康服务系统在本系统之外与医生之间进行的交互，所以在给定的业务背景的情况下，医生不属于本系统的外部实体。再根据描述相关信息进行对应，对照图1-1，即可确定E1为“学生卡”实体，E2为“管理人员”实体，E3为“班主任”实体，E4为“家长”E5为“医护机构健康服务系统”。

【问题2】（4分）使用说明中的词语，给出图1-2中的数据存储D1～D4的名称。

- **D1：学生状态**
  **D2：学生**
  **D3：校园场所**
  **D4：课表**
  （注：名称后面可以带有“信息”以及“文件”或“表”）

  本问题要求确定图1-2中0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明（1）中“采集学生状态”“并记录”，图1-2中从加工“采集学生状态”流入D1的数据流明确了 “学生状态”，可知D1为“学生状态”；再由说明（6）中“基础信息管理”的描述信息，结合图1-2中P6流入D2的“学生基础信息”、流入D3的“校园场所”、流入D4的“课表信息”和从D2流出的“学生信息”等，可知D2为“学生”、D3为“校园场所”、D4为“课表”。

【问题3】（3分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点（三条即可）。

- |    数据流    |        起点        |        终点        |
  | :----------: | :----------------: | :----------------: |
  |   课表信息   |     D4 或 课表     |   P3 或 到课检查   |
  |   场所信息   |   D3 或 校园场所   |   P3 或 到课检查   |
  |   家长信息   |     D5 或 家长     |   P3 或 到课检查   |
  |    家长ID    | P6 或 基础信息管理 |     D2 或 学生     |
  | 家长注册申请 |   P5 或 家长注册   | P6 或 基础信息管理 |

  本问题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，没有缺少与外部实体之间的数据流。再考査题干中的说明判定是否缺失内部的数据流，不难发现图1-2中缺失的数据流。加工P3到课检查需要综合课表信息、校园场所，所以，有从D4课表流向P3到课检查的数据流“课表信息”、从D3校园场所流向P3到课检查的“场所信息”以及从D5家长流向P3到课检查的“家长信息”。加工P4汇总在校情况需要综合学生信息、课表信息、场所信息和学生状态信息，需要从学生信息中获取家长ID，根据家长ID获取家长信息，并将报告发送给家长和班主任，所以，流向P4汇总在校的数据流缺少从D4课表流入的“课表信息”、从D3校园场所流入的“场所信息”和D5家长流入的“家长信息”。再由说明（6）中“对家长注册申请进行审核”“将家长ID加入学生信息记录中使家长与其子女进行关联”不难发现，有从P6基础信息维护流入D2学生的数据流“家长ID”；从P5家长注册流入P6 基础信息管理的“家长注册申请”。

【问题4】（3分）根据说明中的术语，说明图1-1中数据流“学生状态”和“学生信息”的组成。

- **学生状态=学生卡ID+心率+体温+位置+时间**
  **学生信息=学生ID+学生卡ID+1{家长ID}*+班主任ID+班级**

  数据流由具体的数据属性构成采用符号加以表示，“=”表示组成（被定义为），“+”表示有多个属性（与），表示其中属性出现多次，()表示其中属性可选等。图1-1中的“学生状态"来自于E1学生卡，“学生信息"从D2数据存储流出。在说明（1）中给出“采集学生心率、体温（摄氏度）等健康指标及其所在位置”等以及“每张学生卡有唯一的标识（ID）与一个学生对应“；说明（6）中给出说明”对学生及其所用学生卡和班主任“、”将家长ID加入学生信息记录中“等信息。然后采用"="和”+"将数据流及其属性表示出来。需要注意，“一个学生至少有一个家长，可以有多个家长“说明一条学生信息中可以有一到多个家长信息，在数据流表示中需要使用0，即“1{家长10}*"。

### 试题二（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
某创业孵化基地管理若干孵化公司和创业公司，为规范管理创业项目投资业务，需要开发一个信息系统。请根据下述需求描述完成该系统的数据库设计。

【需求描述】
（1）记录孵化公司和创业公司的信息。孵化公司信息包括公司代码、公司名称、法人代表名称、注册地址和一个电话;创业公司信息包括公司代码、公司名称和一个电话。孵化公司和创业公司的公司代码编码不同。
（2）统—管理孵化公司和创业公司的员工。员工信息包括工号、身份证号、姓名、性别、所属公司代码和一个手机号，工号唯一标识每位员工。
（3）记录投资方信息。投资方信息包括投资方编号、投资方名称和一个电话。
（4）投资方和创业公司之间依靠孵化公司牵线建立创业项目合作关系，具体实施由孵化公司的一位员工负责协调投资方和创业公司的一个创业项目。一个创业项目只属于一个创业公司，但可以接受若干投资方的投资。创业项目信息包括项目编号、创业公司代码、投资方编号和孵化公司员工工号。

【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图（不完整）如图2-1所示。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-2-1.jpg)

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）：
孵化公司（公司代码，公司名称，法人代表名称，注册地址，电话）
创业公司（公司代码，公司名称，电话）
员工（工号，身份证号，姓名，性别，（a），手机号）
投资方（投资方编号、投资方名称，电话）
项目（项目编号，创业公司代码，（b），孵化公司员工号）

【问题1】（5分）根据问题描述，补充图2-1的实体联系图。

- 本题考查数据库概念结构设计及逻辑结构转换的掌握。此类题目要求考生认真阅读题目，根据题目的需求描述，给出实体间的联系。
  根据题意由“投资方和创业公司之间依靠孵化公司牵线建立创业项目合作关系，具体实施由孵化公司的一位员工负责协调投资方和创业公司的一个创业项目。”可知投资方、创业公司和员工三方参与项目联系，三方之间为`1:*:1`联系。根据题意由“统一管理孵化公司和创业公司的员工。”可知创业公司和员工之间为`1:*`联系。

【问题2】（4分）补充逻辑结构设计结果中的（a）、（b）两处空缺及完整性约束关系。

- （a）**公司代码**
  （b）**投资方编号**

  根据需求描述（2）可知员工信息包括工号、身份证号、姓名、性别、所属公司代码和一个手机号。所以在员工关系里应该包括“公司代码”，且以外键标识。根据需求描述（4）可知投资方、创业公司和员工三方之间为`1:*:1`联系，所以需要在项目关系模式中包含“投资方编号”，且以外键标识。

【问题3】（6分）若创业项目的信息还需要包括投资额和投资时间，那么：
（1）是否需要增加新的实体来存储投资额和投资时间？
（2）如果增加新的实体，请给出新实体的关系模式，并对图2-1进行补充。如果不需要增加新的实体，请将”投资额“和”投资时间“两个属性补充连线到图2-1合适的对象上，并对变化的关系模式进行修改。

- 补充内容如图中虚线所示：

  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-2-3.jpg)

  （1）**不需要**
  （2）**关系模式：项目（项目编号，创业公司代码，投资方编号，孵化公司员王号投资额，投资时间）**

  根据题意由“创业项目的信息还需要包括投资额和投资时间”，可知不需要增加新的实体来存储投资额和投资时间，只需要在项目关系模式中增加“投资额”和“投资时间”两个属性。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某图书公司欲开发一个基于Web的书籍销售系统，为顾客（Customer）提供在线购买书籍（Books）的功能，同时对公司书籍的库存及销售情况进行管理。系统的主要功能描述如下：
（1）首次使用系统时，顾客需要在系统中注册（Register detail）。顾客填写注册信息表要求的信息，包括姓名（name）、收货地址（address）、电子邮箱（email）等，系统将为其生成一个注册码。
（2）注册成功的顾客可以登录系统在线购买书精（Buy books）。购买时可以浏览书籍信息，包括书名（title）、作者（author）、内容简介（introduction）等。如果某种书籍的库存量为0，那么顾客无法查询到该书籍的信息。顾客选择所需购买的书籍及购买数量（quantities），若购买数量超过库存量，提示库存不足;若购买数量小于库存量，系统将显示验证界面，要求顾客输入注册码。注册码验证正确后，自动生成订单（Order），否则，提示验证错误。如果顾客需要，可以选择打印订单（Print order）。
（3）派送人员（Dispatcher）每天早晨从系统中获取当日的派送列表信息（Produce picklist），按照收货地址派送顾客订购的书籍。
（4）用于销售的书籍由公司的采购人员（Buyer）进行采购（Reorder books）。采购人员每天从系统中获取库存量低于再次订购量的书籍信息，对这些书籍进行再次购买，以保证充足的库存量。新书籍到货时，采购人员向在线销售目录（Catalog）中添加新的书籍信息（Add books）。
（5）采购人员根据书籍的销售情况，对销量较低的书籍设置折扣或促销活动（Promote books）。（6）当新书籍到货时，仓库管理员
（Warehouseman）接收书籍，更新库存（Update stock）。
现采用面向对象方法开发书籍销售系统，得到如图3-1所示的用例图和图3-2所示的初始类图（部分）。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-3-1.jpg)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-3-2.jpg)

【问题1】（6分）根据说明中的描述，给出图3-1中A1～A3所对应的参与者名称和U1～U3处所对应的用例名称。

- **A1：Buyer或采购人员**
  **A2：Warehouseman或仓库管理员**
  **A3：Dispatcher或派送人员**
  **U1：Register details 或注册**
  **U2：Print order 或打印订单**
  **U3：Buy books或在线购买书籍**

  本题主要考查面向对象分析与设计的基本概念。在建模方面，本题仅涉及UML的用例图和类图，考查的模式是根据需求说明将模型补充完整。题目较为简单，属于经典考题。本题给出的应用场景是一个基于Web的书籍销售系统。本问题要求补充的是用例图。用例图展现一组用例、参与者以及它们之间的关系。用例建模是按照业务事件、谁发起事件，以及系统如何响应事件建模系统功能的过程。
  参与者表示需要与系统交互以交换信息的任何事物。参与者可以是一个用户，可以是外部系统的一个角色，也可以是一个人。从题目的说明中可以很容易发现，该系统中有4类与系统交互的角色：顾客、派送人员、采购人员以及仓库管理员。根据说明所描述的每个角色所参与的功能，可以判断出：A1对应的参与者是采购人员（Buyer）、A2对应的参与者是仓库管理员（Warehouseman）、A3对应的参与者是派送人员（Dispatcher）。
  用例是一组相关行为的自动的和手动的步骤序列，其目的是为了完成单个业务任务。下面需要确定与参与者“顾客（Customer）”相关联的用例。根据说明可知，顾客参与或激发的用例包括：注册（Register detail）、在线购买书籍（Buy books）和印订单 (Print Order）。由图3-1可知，用例U2和U3之间具有扩展关系。为了间化用例使其更要容易理解，通常会提取出复杂的步骤，使其成为独立的用例，这类用例被称为扩展用例。而“打印订单”是“在线购买书籍”中的一部分操作，可以作为独立步骤提取，所以图3-1中U2对应的用例为“打印订单”，U3为“在线购买书籍”，U1为“注册”。

【问题2】（6分）根据说明中的描述，给出图3-1中用例U3的用例描述。（用例描述中必须包括基本事件流和所有的备选事件流）。

- 基本事件流：**顾客登录系统，浏览书籍信息，选择所需购买的书籍及其数量，进入验证界面，输入注册码，生成订单**。
  备选事件流：
  （1）**书籍的购买数量大于其库存量，提示库存不足**。
  （2）**注册码不正确，提示验证码错误**。
  （3）**顾客要求打印订单信息**。

  UML的用例图以图形化的方式描述了系统与外部系统和用户的交互。用例描述也用于以文本化的方式描述每个交互步骤的顺序。本题考查的就是用例的文本描述方式。需要进行描述的用例是U3，即“在线购买书籍”。根据说明中的（2），可以很容易得到该用例的交互步骤，这里需要注意的是要区分基本事件流和备选事件流，并且要给出所有的备选事件流。
  基本事件流为：顾客登录系统，浏览书籍信息，选择所需购买的书籍及其数量，进入验证界面，输入注册码，生成订单。
  备选事件流一共有3个场景：购买数量超过库存量、验证码错误以及是否需要打印。

【问题3】（3分）根据说明中的描述，给出图3-2中C1～C3所对应的类名。

- **C1：Customer**
  **C2：Order**
  **C3：Books**

  本问题要求将图3-2所示的类图补充完整。首先观察该类图，发现在图中有两个聚集关系（整体—部分）——Catalog与C3，C2与OrderedBook。从说明可知，“采购人员向在线销售目录（Catalog）中添加新的书籍信息”，所以Catalog中包含应该是书籍的信息，因此C3应该对应类Books。同时由类图3-1也可以看出，C3中的属性与“Books”的属性也是一致的。同理，可以推断出C2对应的是类“Order”，C1对应的是类“Customer”。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
`n`皇后问题描述为:在一个`n×n`的棋盘上摆放n个皇后，要求任意两个皇后不能冲突，即任意两个皇后不在同一行、同一列或者同一斜线上。算法的基本思想如下：
将第`i`个皇后摆放在第`i`行，`i`从1开始，每个皇后都从第1列开始尝试。尝试时判断在该列摆放皇后是否与前面的皇后有冲突，如果没有冲突，则在该列摆放皇后，并考虑摆放下一个皇后；如果有冲突，则考虑下—列。如果该行没有合适的位置，回溯到上—个皇后，考虑在原来位置的下一个位置上继续云试摆放皇后，...，直到找到所有合理摆放方案。

【C代码】
常量和变量说明：`n`是皇后数，棋盘规模为`n×n`，`queen[]`是皇后的摆放位置数组，`queen[i]`是第`i`个皇后的位置，`1≤queen[i]≤n`。
下面是算法的C语言的代码实现。

```c
#include <stdio.h>

#define n 4
int queen[n + 1];
void show() {  /* 输出所有皇后摆放方案 */
    int i;
    printf("(");
    for(i = 1; i <= n; i++) {
        printf(" %d"，queen[i]);
    }
    printf(")\n");
}

int Place(int j) {  /* 检查当前列能否放皇后，不能放返回0，能放返回1 */
    int i;
    for(i = 1; i < j; i++) {  /* 查与已摆放的皇后是否在同一列或者同一斜线上 */
        if(__(1)__ || abs(queen[i]-queen[j]) == (j-i)) {
            return 0;
        }
    }
    return __(2)__;
}

void Nqueen(int j) {
    int i;
    for(i = 1; i <= n; i++) {
        queen[j] = i;
        if(__(3)__) {
            if (j == n) {  /* 如果所有皇后都摆放好，则输出当前摆放方案 */
                show();
            } else {  /* 否则继续摆放下一个皇后 */
                __(4)__;
            }
        }
    }  
}

int main() {
    Nqueen(1);
    return 0;
}
```

【问题1】（8分）根据题干说明，填充C代码中的空（1）～（4） 。

（1）**`queen[i]==queen[j]`** 或等价形式
（2）**`1`**
（3）**`Place(j)`**
（4）**`Nqueen(j+1)`**

本题考查算法设计策略与分析方法。此类题目要求考生认真阅读题目对问题的描述，以及用算法求解该问题的思路，能够理解如何将典型的算法设计策略应用到实际问题的求解中，并用某种程序设计语言来实现。
函数`Place`用于检查当前行`j`的`queen[j]`位置能否放置皇后，不能放则返回0，能放则返回1。能放的前提是前`j-1`行已经放置了互相不冲突的皇后，此时判断第j行的皇后`queen[j]`是否与前面的皇后有冲突，因此判断if中的两个条件为是否在同一列或同一对斜线。其中，`abs(queen[i]-queen[j])==(j-i)`表示两个皇后在同一斜线上，因此（1）中应填同一列，即`queen[i]==queen[j]`。在定义函数`Place`的时候己经注释说明，如果不能放返回0，能放返回1，因此（2）填`1`。在函数`Nqueen`中放置皇后。从第一行第一列开始，每次放置皇后是判断是否可以放置的位置，因此（3）填`Place(j)`。如果能放且`j`是最后一行，则得到一个放置方案；如果能放且j不是最后一行，则需要放下一个皇后，因此（4）填写`Nqueen(j+1)`。这里用到了递归调用，因此没有显式回溯的语句。

【问题2】（3分）根据题干说明和C代码，算法采用的设计策略为（5）。

- （5）**回溯法**

  这是一个典型的回溯算法求解问题的过程。分治法、动态规划、贪心算法、回溯法和分支限界法是要求考生掌握的算法设计策略，考生需要理解算法求解问题的基本步骤以及应用该算法策略求解的典型例子。

【问题3】（4分）当n=4时，有（6）种摆放方式，分别为（7）。

- （6）**2**
  （7）**(2, 4, 1, 3)**，**(3, 1, 4, 2)**
  根据对问题的描述和C语言实现，可以摆放皇后获得问题的解。当n=4时，有两种摆放方案，如下图所示，其中◇表示皇后。因此（6）中填2，（7）中填 (2, 4, 1, 3) 和 (3, 1, 4, 2)。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-4-1.jpg)

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。
【说明】
某软件公司欲开发—款汽车竞速类游戏，需要模拟长轮胎和短轮胎急刹车时在路面上留下的不同痕迹，并考虑后续能模拟更多种轮胎急刹车时的痕迹。现采用策略（Strategy）设计模式来实现该需求，所设计的类图如图5-1所示。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-5-1.jpg)

【C++代码】

```c++
#include <iostream>
using namespace std;

class BrakeBehavior {
public:
    __(1)__;
    /* 其余代码省略 */
};

class LongWheelBrake : public BrakeBehavior {
public:
    void stop() { cout << "模拟长轮胎刹车痕迹!" << endl; }
    /* 其余代码省略 */
};

class ShortWheelBrake : public BrakeBehavior {
public:
    void stop() { cout << "模拟短轮胎刹车痕迹!" << endl; }
    /* 其余代码省略 */
};

class Car {
protected:
    __(2)__ wheel;
public:
    void brake() {
        __(3)__;
    }
    /* 其余代码省略 */
};

class ShortWheelcar : public Car {
public:
    ShortWheelcar(BrakeBehavior *behavior) {
        __(4)__;
        /* 其余代码省略 */
    }
};

int main() {
    BrakeBehavior *brake = new ShortWheelBrake();
    ShortWheelcar car1(brake);
    car1.__(5)__;
    return 0;
}
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`virtual void stop()=0`**
  （2）**`BrakeBehavior*`**
  （3）**`wheel->stop()`**
  （4）**`wheel=behavior`**
  （5）**`brake()`**

  本题考查设计模式中策略（Strategy）模式的基本概念和应用。策略模式的意图是，定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化，策略模式的结构图如图5-2所示。

  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2019s-5-2.jpg)

  其中：`Strategy`（策略）定义所有支持的算法的公共接口。`Context`使用这个接口来调用某`ConcreteStrategy`定义的算法。
  `ConcreteStrategy`（具体策略）以`Strategy`接口实现某具体算法。`Context`（上下文）用一个`ConcreteStrategy`对象来配置；维护一个对`Strategy`对象的引用；可定义一个接口来让`Strategy`访问它的数据。
  策略模式适用于：许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。需要使用一个算法的不同变体。例如，定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。
  算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。
  本题中的类`BrakeBehavior`对应于图5-2中的`Strategy`，类`LongWheelBrake`和`ShortWheelBrake`则是具体的策略子类，每个子类以`Strategy`提供的接口实现某具体算法。
  第（1）空需要填写的就是类`BrakeBehavior`中所定义的接口，这一空的答案可以从`BrakeBehavior`的子类中得出。这里釆用了C++中的纯虚拟函数机制，使`BrakeBehavior`成为了抽象基类，为其子类提供统一操作接口，具体实现则由子类来实现。因此，第（1）空应填入`virtual void stop()=0`。
  第（2）空和第（3）空在类`Car`中。类`Car`对应于图5-2中的类`Context`，其作用是：用一个`ConcreteStrategy`对象来配置，维护一个对`Strategy`对象的引用，定义一个接口来让`Strategy`访问它的数据。第（2）空用于定义和维护对Strategy对象的引用，这里需要给出其类型，因此第（2）空应填入`BrakeBehavior*`。第(3)空要求给出方法`brake`的实现，这里需要调用策略类所提供的策略，因此第（3）空应填入`wheel->Stop()`。
  第（4）空是在为Car的子类设置`ConcreteStrategy`对象，因此第（4）空应填入`wheel=behavior`。
  第（5）空考查的是对策略模式的使用，这里需要调用Car中所定义的接口brake，因此第（5）空应填入`brake()`。

------

## 2018年下半年案例试题

### 试题一（共15分）

阅读下列说明和图，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某房产中介连锁企业欲开发一个基于Web 的房屋中介信息系统,以有效管理房源和客户，提高成交率。该系统的主要功能是：
（1）房源采集与管理。系统自动采集外部网站的潜在房源信息，保存为潜在房源。由经纪人联系确认的潜在房源变为房源，并添加出售/出租房源的客户。由经纪人或客户登记的出售/出租房源，系统将其保存为房源。房源信息包括基本情况、配套设施、交易类型、委托方式、业主等。经纪人可以对房源进行更新等管理操作。
（2）客户管理。求租/求购客户进行注册、更新，推送客户需求给经纪人，或由经纪人对求租/求购客户进行登记、更新。客户信息包括身份证号、姓名、手机号、需求情况、委托方式等。
（3）房源推荐。根据客户的需求情况（求购/求租需求情况以及出售/出租房源信息），向已登录的客户推荐房源。
（4）交易管理。经纪人对租售客户双方进行交易信息管理，包括订单提交和取消，设置收取中介费比例。财务人员收取中介费之后，表示该订单已完成，系统更新订单状态和房源状态，向客户和经纪人发送交易反馈。
（5）信息查询。客户根据自身查询需求查询房屋供需信息。现采用结构化方法对房屋中介信息系统进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-1-1.png)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-1-2.png)

【问题1】（4分）使用说明中的词语，给出图1-1中的实体E1～E4的名称。

- **E1：客户**
  **E2：经纪人**
  **E3：财务人员**
  **E4：外部网站**

  本题考查采用结构化方法进行软件系统的分析与设计，主要考查利用数据流图（DFD）进行需求分析和建模。DFD是面向数据流建模的工具，它将系统建模成输入、加工（处理）、输出的模型，即流入软件的数据对象、经由加工的转换、最后以结果数据对象的形式流出软件，并采用自顶向下分层建模进行逐层细化。
  顶层DFD（上下文数据流图）建模用于确定系统边界以及系统的输入输出数据，待开发软件系统被看作一个加工，为系统提供输入数据以及接收系统输出数据的是外部实体，外部实体和加工之间的输入输出即为数据流。数据流或者由具体的数据属性（也称为数据结构）构成，或者由其他数据流构成，即组合数据流，用于在高层数据流图中组合相似的数据流。将上下文DFD中的加工分解成多个加工，分别识别这些加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。
  在建模分层DFD时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工。注意要在绘制下层数据流图时保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。
  题目题干描述清晰，易于分析，要求考生细心分析题目中所描述的内容。
  本问题考查的是上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统名称“房屋中介系统”作为唯一加工的名称，为这一加工提供输入数据流或者接收其输出数据流的外部实体，涉及到外部网站、经纪人、客户和财务人员，再根据描述相关信息进行对应，对照图1-1，即可确定E1为“客户”实体，E2为“经纪人”实体，E3为“财务人员”实体，E4为“外部网站”。

【问题2】（4分）使用说明中的词语，给出图1-2中的数据存储D1～D4的名称。

- **D1：客户记录**
  **D2：潜在房源记录**
  **D3：房源记录**
  **D4：订单记录**

  本问题要求确定图1-2 0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明1中“系统自动采集外部网站的潜在房源信息，保存为潜在房源”，可知加工“房源采集与管理”向存储中写入新的潜在房源信息，由此可知D2为“潜在房源”；再由说明1中“由经纪人联系确认的潜在房源变为房源”等信息，可知此加工需要向存储中写入新房源信息，由此可知D3为“房源”。说明2中“求租/求购客户进行注册”和“或由经纪人对求租/求购客户进行登记”可知加工“客户管理”向D1中添加新客户信息，由此可知D1为“客户”。说明4中交易管理“经纪人对租售客户双方进行交易信息管理，包括“订单提交和取消”、“系统更新订单状态”等，可知D4为“订单”。

【问题3】（3分）根据说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |    数据流    |      起点      |         终点         |
  | :----------: | :------------: | :------------------: |
  | 检索潜在房源 | D2 或 潜在房源 | P1 或 房源采集与管理 |
  | 客户需求情况 |   D1 或 客户   |    P3 或 房源推荐    |
  |   交易反馈   | P4 或 交易管理 |     E2 或 经纪人     |
  |   房源状态   | P4 或 交易管理 |      D3 或 房源      |

  本问题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，缺少了从加工到外部实体E2（经纪人）的数据流——“交易反馈”，说明4中，交易管理需“向客户和经纪人发送交易反馈”，可以此数据流起点为P4（交易反馈），终点为E2。再考查题干中的说明判定是否缺失内部的数据流，不难发现图1-2中缺失的数据流。根据说明1的描述“系统自动采集外部网站的潜在房源信息，保存为潜在房源。由经纪人联系确认的潜在房源变为房源”可知加工房源采集与管理（P1）从潜在房源（D2）读取数据进行确认，说明3 “根据客户的需求情况向已登录的客户推荐房源”可知加工房源推荐（P3）从存储客户（D1）获取“需求情况”，说明4中“系统更新订单状态和房源状态”可知交易管理（P4）需更新房源（D3）的状态。

【问题4】（4分）根据说明中术语，给出图1-1中数据流“客户信息”、“房源信息”的组成。

- **客户信息=身份证号+姓名+手机号+需求情况+委托方式**
  **房源信息=基本情况+配套设施+交易类型+委托方式+业主**

### 试题二（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】
某集团公司拥有多个分公司，为了方便集团公司对分公司各项业务活动进行有效管理，集团公司决定构建一个信息系统以满足公司的业务管理需求。
【需求分析】
（1）分公司关系需要记录的信息包括分公司编号、名称、经理、联系地址和电话。分公司编号唯一标识分公司信息中的每一个元组。每个分公司只有一名经理，负责该分公司的管理工作。每个分公司设立仅为本分公司服务的多个业务部门，如研发部、财务部、采购部、销售部等。
（2）部门关系需要记录的信息包括部门号、部门名称、主管号、电话和分公司编号。部门号唯一标识部门信息中的每一个元组。每个部门只有一名主管，负责部门的管理工作。每个部门有多名员工，每名员工只能隶属于一个部门。
（3）员工关系需要记录的信息包括员工号、姓名、隶属部门、岗位，电话和基本工资。其中，员工号唯一标识员工信息中的每一个元组。岗位包括：经理、主管、研发员、业务员等。
【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图和关系模式（不完整）如图2-1所示。
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-2-1.png)

【关系模式设计】
分公司（分公司编号，名称，（a），联系地址，电话）
部门（部门号，部门名称，（b），电话）
员工（员工号，姓名，（c），电话，基本工资）

【问题1】（4分）根据问题描述，补充4个联系，完善图2-1的实体联系图。联系名可用联系1、联系2、联系3和联系4代替，联系的类型为`1:1`、`1:n`和`m:n`（或`1:1`、`1:*`和`*:*`）。

- 完善后的实体联系图如下所示（所补充的联系和类型如虚线所示）：
  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-2-2.png)

  本题考查数据库系统中实体联系模型(E-R模型)和关系模式设计方面的基础知识。 
  可分析如下：
  ①根据题意“每个分公司包含有不同的部门，但一个部门只对应一个分公司。”分公司和部门之间有一个“组成”联系，联系类型为`1:*`。
  ②根据题意“每个分公司只有一名经理，负责该分公司的管理工作。”所以分公司和经理之间有一个“管理1”联系，联系类型为`1:1`。
  ③根据题意“每个部门只有一名主管，只负责管理本部门的工作。”所以部门和主管之间有一个“管理2”联系，联系类型为`1:1`。
  ④根据题意“一个部门有多名员工，每名员工只属于一个部门。”，部门和员工之间有一个“隶属”联系，联系类型为`1:*`。

【问题2】（5分）根据题意，将关系模式中的空（a）～（c）补充完整。

- （a）**经理**；
  （b）**主管号，分公司编号**；
  （c）**隶属部门（或部门号），岗位**。

  根据【需求分析】（1）分公司需要记录的信息包括公司编号、名称、经理（应参照员工关系的员工号）、联系地址和电话”，所以空（a）应填写“经理”。
  根据【需求分析】（2）部门需要记录的信息包括部门号、部门名称、主管号（应参照员工关系的员工号）、电话、分公司编号”，所以空（b）应填写“主管号，分公司编号”。
  根据【需求分析】（3）员工需要记录的信息包括员工号、姓名、隶属部门、岗位，电话号码和基本工资，所以空（c）应填写“隶属部门，岗位”。

【问题3】（4分）给出“部门”和“员工”关系模式的主键和外键。

- “部门”关系模式的主键为：**部门号**，外键为：**主管号、分公司编号**; 
  “员工”关系模式的主键为：**员工号**，外键为：**部门号**。

  根据题干所述“部门号唯一标识部门信息中的每一个元组”，部门关系的主键为部门号。由于部门关系中的“主管号”必须参照员工关系的员工号，“分公司编号”必须参照分公司关系的分公司编号，故部门关系的外键为主管号、分公司编号。
  根据题干所述“员工号唯一标识员工信息中的每一个元组”，故员工关系的主键为员工号；又由于隶属部门必须参照部门关系的部门号，故员工关系的外键为隶属部门。

【问题4】（2分）假设集团公司要求系统能记录部门历任主管的任职时间和任职年限，那么是否需要在数据库设计时增设一个实体？为什么？

- **“是”**或“需要”。**部门与历任主管之间的联系类型是的必须建立一个独立的关系模式，该模式的属性由两端的码加上联系的属性构成**。

  如果需要系统能记录部门历任主管的任职时间，那么“在数据库设计时需要增设一个实体”的说法是正确的。因为部门与历任主管之间的联系类型是`*:*`的，必须建立一个独立的关系模式，该模式为（部门号，历任主管，任职时间）。

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。

【说明】
社交网络平台（SNS）的主要功能之一是建立在线群组，群组中的成员之间可以互.相分享或挖掘兴趣和活动。每个群组包含标题、管理员以及成员列表等信息。
社交网络平台的用户可以自行选择加入某个群组。每个群组拥有一个主页，群组内的所有成员都可以查看主页上的内容。如果在群组的主页上发布或更新了信息，群组中的成员会自动接收到发布或更新后的信息。
用户可以加入一个群组也可以退出这个群组。用户退出群组后，不会再接收到该群组发布或更新的任何信息。
现采用面向对象方法对上述需求进行分析与设计，得到如表3-1所示的类列表和如图3-1所示的类图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-3-1.png)

【问题1】（6分）根据说明中的描述，给出图3-1中C1～C3所对应的类名。

- **C1：SNSGroup**；
  **C2：SNSUser**；
  **C3：SNSAdmin**。
  （其中C2、C3可以互换）

  本题主要考查面向对象分析与设计应用。在建模方面，本题仅涉及到了UML的类图，要求根据需求说明将模型补充完整。题目较为简单，属于经典考题。本题给出的应用场景是社交网络平台中的在线群组。根据题干说明和表3-1给出的类列表，类之间的关系比较明确。在图3-1所示的类图中，有一个继承结构：`SNSObserver`、C2和C3。表3-1中给出了5个类，图3-1中标识出了2个。根据说明，在剩下的3个类中，能够与这个继承结构相匹配的类只有`SNSUser`和`SNSAdmin`了。那么C1对应的就是类`SNSGroup`。

【问题2】（6分）图3-1中采用了哪一种设计模式？说明该模式的意图及其适用场合。

- **观察者（Observer）模式**。
  意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新**。
  **观察者模式的适用场合**：
  （1）当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。
  （2）当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。
  （3）当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。

  图3-1中采用的是观察者（Observer）模式。观察者模式的意图是，定义吋象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
  观察者模式的结构图如图3-2所示，其中：
  `Subject`（目标）知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口。
  `Observer`（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。
  `ConcreteSubject`（具体目标）将有关状态存入各`ConcreteObserver`对象；当它的状态发生改变时，向它的各个观察者发出通知。
  `ConcreteObserver`（具体观察者）维护一个指向`ConcreteSubject`对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口，以使自身状态与目标的状态保持一致。

【问题3】（3分）现在对上述社交网络平台提出了新的需求：一个群体可以作为另外一个群体中的成员，例如群体A加入群体B。那么，群体A中的所有成员就自动成为群体B中的成员。若要实现这个新需求，需要对图3-1进行哪些修改?（以文字方式描述）

- 针对“一个群组可以作为另外一个群组中的成员，即群组是可以嵌套的”这个新需求，对图3-2所示的类图需要进行如下修改：
  （1）**在`SNSSubject`和`SNSObserver`之间增加继承关系，其中`SNSObserver`为基类，`SNSSubject`为派生类**。
  （2）**为类`SNSGroup`增加自关联关系**（自己到自己的关联关系）。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1至问题3，将解答写在答题纸的对应栏内。

【说明】
给定一个字符序列$B=b_1,b_2,...,b_n$，其中$b_i \in {A,C,G,U}$。B上的二级结构是一组字符对集合$S={(b_i,b_j)}$，其中$i, j\in {1,2,...,n}$，并满足以下四个条件：

（1）S中的每对字符是$(A,U)$，$(U,A)$，$(C,G)$和$(G,C)$四种组合之一；

（2）S中的每对字符之间至少有四个字符将其隔开，即$i<j-4$；

（3）S中每一个字符（记为$b_k$）的配对存在两种情况：$b_k$不参与任何配对；$b_k$和字符$b_t$配对，其中$t<k-4$；

（4）(不交叉原则）若$(b_i,b_j)$和$(b_k,b_l)$是S中的两个字符对，且$i<k$，则$i<k<j<l$不成立。

$B$的具有最大可能字符对数的二级结构$S$被称为最优配对方案，求解最优配对方案中的字符对数的方法如下：
假设用$C(i,j)$表示字符序列$b_ib_{i+1}...b_j$的最优配对方案（即二级结构S）中的字符对数，则$C(i,j)$可以递归定义为：
$$
C(i, j)=\left\{\begin{array}{ll}
\max (C(i, j-1), \max (C(i, t-1)+1+C(t+1, j-1))) & \text { 若 } b_{t} \text { 和 } b_{j} \text { 匹配且 } i<j-4 \\
0 & \text { 否则 }
\end{array}\right.
$$
下面代码是算法的C语言实现，其中：`n`是字符序列长度，`B[]`是字符序列，`C[][]`是最优配对数量数组。

【C代码】

```c
#include <stdio.h>
#include <stdlib.h>
#define LEN 100

/*判断两个字符是否配对*/
int isMatch(char a, char b) {
    if((a -= 'A' && b -= 'U') || (a -= 'U’&& b == 'A'))
        return 1;
    if((a -= 'C' && b -= 'G') || (a -= 'G’ && b -= 'C'))
        return 1;
    return 0;
}

/*求最大配对数*/
int RNA_2(char B[LEN], int n) {
    int i, j, k, t;
    int max;
    int C[LEN][LEN] = {0};
    for(k = 5; k <= n-1; k++) {
        for(i = 1; i <= n-k; i++){
            j = i + k;
            __(1)__;
            for(__(2)__; t <= j-4; t++) {
                if(__(3)__ && max < C[i][t-1]+1+C[t+1][j-1])
                    max = c[i][t-1]+1+C[t+1][j-1];
            }
            C[i][j] = max;
            printf("c[%d][%d] = %d--", i, j, C[i][j]);
        }
    }
    return __(4)__;
}
```

【问题1】（8分）根据题干说明，填充C代码中的空（1）～（4）。

- （1）**`max=C[i][j-1]`**
  （2）**`t=i`**
  （3）**`isMatch(B[t],B[j])`** 或其等价形式
  （4）**`C[1][n]`**

  本题考査算法设计与分析以及用C程序设计语言实现算法的能力。要求考生要熟练掌握几种常用的算法设计策略的基本概念、解题思路、实现方法和时间复杂度分折方法。本题是采用动态规划方法求解RNA序列的二级结构。
  在C函数`isMatch`中，判断两个字符是否匹配。
  在C函数`RNA_2`中，求解最大的匹配数。代码涉及到三重`for`循环。最外`for`循环中的循环变量k表示字符间隔长度，中间for循环的循环变量i表示待考虑的子问题的起始字符下标，根据`i`和`k`可以确定`j`，即待考虑的子问题。每次先假设该子问题的值为也就是题干中递归式第一部分中的前一部分，因此空（1）填写`max=C[i][j-1]` 。最内层`for`循环中的循环变量`t`是求解问题$b_ib_{i+1}...b_j$的子问题的最优匹配数，也就是题干中递归式第一部分中的后一部分，`t`从`i`开始，因此空（2）处填`t=i`。判断语句`if`中其实是实现递归式第一部分的条件，也就是`B[t]`和B`[j]`是否匹配，因此空（3）处填写`isMatch(B[t],B[j])`，注意条件`i<j-1`已经在循环中约束。空（4）处要填返回值，即`C[1][n]`。

【问题2】（4分）根据题干说明和C代码，算法采用的设计策略为（5）。算法的时间复杂度为（6）（用О表示）。

- （5）**动态规划法**
  （6）$O(n^3)$

【问题3】（3分）给定字符序列ACCGGUAGU，根据上述算法求得最大字符对数为（7）。

- （7）2

  运行上述C程序，得到：
  `c[1][6]=1`，`c[2][7]=0`，`c[3][8]=1`， `c[4][9]=0`；
  `c[1][7]=1`，`c[2][8]=1`，`c[3][9]=1`；
  `c[1][8]=1`，`c[2][9]=1`；
  `c[1][9]=2`。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。

【说明】
某航空公司的会员积分系统将其会员划分为：普卡（`Basic`）、银卡（`Silver`）、金卡（`Gold`）以及三个等级。非会员（`NonMember`） 可以申请成为普卡会员。会员的等级根据其一年内累积的里程数进行调整。描述会员等级调整的状态图如图5-1所示。现采用状态（`State`）模式实现上述场景，得到如图5-2所示的类图。

<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-5-1.png" style="zoom:80%;" />
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-5-2.png" style="zoom:80%;" />

【C++代码】

```c++
#include <iostream>
using namespace std;

class CFrequentFlyer; 
class CBasic; 
class CSilver; 
class CGold; 
classCNoCustomer;
//提前引用
class CState {
private: 
    int flyMiles;  //里程数
public:
    __(1)__;  //根据累积里程数调整会员等级
};

class CFrequentFlyer {
    friend class CBasic; 
    friend class CSilver; 
    friend class CGold;
private:
    CState *state; 
    CState *nocustomer;
    CState *basic;
    CState *silver;
    CState *gold;
    double flyMiles;
public:
    CFrequentFlyer () { flyMiles = 0; setState(nocustomer); }
    void setState (CState *state) { this->state = state; }
    void travel (int miles) {
        double bonusMiles = state->travel(miles, this);
        f1yMiles = f1yMiles + bonusMiles;
    }
};

class CNoCustomer : public CState {  //非会员
public:
    double travel(int miles, CFrequentFlyer* context) {  //不累积里程数
        cout << "Your travel will not account for points\n";
        return miles;
    }
};

class CBasic : publicState {  //普卡会员
public:
    double travel(int miles, CFrequentFlyer* context) {
        if(context->flyMiles >= 25000 && context->flyMiles < 50000)
            __(2)__;
        if(context->flyMiles >= 50000)
            __(3)__;
        return miles + 0.5*miles;  //累积里程数
    }
};

class CGold : public CState {  //金卡会员
public:
    double travel (int miles, CFrequentFlyer* context) {
        if(context->flyMiles >= 25000 && context->flyMiles < 50000)
            __(4)__;
        if(context->flyMiles < 25000)
            __(5)__;
        return miles + 0.5*miles;  //累积里程数
    }
};

class CSilver : public CState {  //银卡会员
public:
    double travel(int miles, CFrequentFlyer* context) {
    if(context->f1yMiles < 25000)
        context->setState(context->basic);
    if(context->flyMiles >= 50000)
        context->setState (context->gold);
        return (miles + 0.25*miles);
    }
};
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`virtual double travel(int miles, FrequentFlyer* context)=0`**
  （2）**`context->setState(context->silver)`**
  （3）**`context->setState(context->gold)`**
  （4）**`context->setState(context-> silver)`**
  （5）**`context->setState(context->basic)`**

  本题考查设计模式中状态（State）模式的基本概念和实现。状态模式的意图是，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。状态模式的结构图如图5-3所示。
  ![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018x-5-3.png)

  其中：
  `Context`（上下文）定义客户感兴趣的接口，维护一个`ConcreteState`子类的实例，这个实例定义当前状态。
  `State`（状态）定义一个接口以封装与`Context`的一个特定状态相关的行为。
  `ConcreteState`（具体状态子类）的每个子类实现与`Context`的一个状态相关的行为。

  状态模式适用于以下情形：
  一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。
  一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
  这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。`State`模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。
  本题中的类`CState`对应于图5-3中的`State`，类`CNonMember`、`CBasic`、`CSilver` 和`CGold`则是具体的状态子类，每个子类实现与`CFrequentFlyer`（对应图5-3中的`Context`） 的一个状态相关的行为。
  第（1）空需要填写`CState`中的核心方法，这个方法将在`CFrequentFlyer`中被调用，该空的答案可以从`CState`的子类中得出。这里采用了C++中的纯虚拟函数机制，使`CState`成为了抽象基类，为其子类提供统一操作接口，具体实现则由子类来实现。因此第（1）空应填入`virtual double travel(int miles, FrequentFlyer* context)=0`。
  第（2）～（5）空体现的是4个具体状态一普卡（`Basic`）、银卡（`Silver`）、金卡（`Gold`）以及非会员（`NonMember`） 之间的转换，如图5-1所示。对于普卡会员，当累积的里程数大于等于25000并且小于50000时，可升级为银卡会员，即类`CFrequentFlyer`所维护的状态应被设置为银卡（也就是`CSilver`的实例）。状态的设置需要调用类`CFrequentFlyer`中的方法`setState`，这个方法的形参类型是`CState*`，可以接受`CState`以及其子类类型的实参。这种类型转换是由面向对象程序设计中的继承机制保证的。因此第（2）空应填入`context->setState(context->silver)`。同理，根据图5-1，第（3）空应填入`context->setState(context->gold)`。第（4）空和第（5）空在类`CGold`中，根据图5-1可知，第（4）空应填入`context->setState(context-> silver)`；第（5） 空应填入`context->setState(context->basic)`。

------

## 2018年上半年案例试题

### 试题一（共15分）

阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。
【说明】某医疗护理机构为老年人或有护理需求者提供专业护理,现欲开发一基于Web 的医疗管理系统，以改善医疗护理效率。该系统的主要功能如下：
（1）通用信息查询。客户提交通用信息查询请求，查询通用信息表，返回查询结果。
（2）医生聘用。医生提出应聘/辞职申请，交由主管进行聘用/解聘审批，更新医生表，并给医生反馈聘用/解聘结果；删除解聘医生的出诊安排。
（3）预约处理。医生安排出诊时间，存入医生出诊时间表；根据客户提交的预约查询请求，查询在职医生及其出诊时间等预约所需数据并返回；创建预约，提交预约请求，在预约表中新增预约记录，更新所约医生出诊时间并给医生发送预约通知；给客户反馈预约结果。
（4）药品管理。医生提交处方，根据药品名称从药品数据中查询相关药品库存信息，开出药品，更新对应药品的库存以及预约表中的治疗信息；给医生发送“药品已开出”反馈。
（5）报表创建。根据主管提交的报表查询请求（报表类型和时间段），从预约数据、通用信息、药品库存数据、医生以及医生出诊时间中进行查询，生成报表返回给主管。
现采用结构化方法对医疗管理系统进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-1-1.png)

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-1-2.png)

【问题1】（3分）使用说明中的词语，给出图1-1中的实体E1～E3的名称。
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-1-1.png" style="zoom: 80%;" />

- **E1：客户**，**E2：医生**，**E3：主管**。
  本题考查采用结构化方法进行软件系统的分析与设计，主要考查数据流图（DFD）的应用，考点与往年类似。DFD是结构化分析与设计方法中面向数据流建模的工具，它将系统建模成输入、加工（处理）、输出的模型，并采用自顶向下分层且逐层细化的方式，建模不同详细程度的数据流图模型。首先需要建模上下文数据流图（顶层DFD）来确定系统边界。在上下文DFD中，待开发软件系统被看作一个加工，为系统提供输入数据以及接受系统输出数据的外部实体，外部实体和加工之间的输入输出即为流入和流出系统的数据流。在上下文DFD中确定的外部实体以及与外部实体的输入输出数据流的基础上，将上下文DFD中的加工分解成多个加工，分别识别这些加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进—步建模加工的内容。在建模分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中。建模时，需要注意加工和数据流的使用原则，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工。注意要在绘制下层数据流图时保持父图与子图之间的平衡，即：父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流并集。本题题下描述清晰，易于分析，分析题目中所描述的内容，完成对应题目。本题考查上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统名称“医疗管理系统"作为唯一加工的名称，外部实体为这一加工提供输入数据流或者接收其输出数据流。通过考查系统的主要功能发现，系统中涉及客广、医生、主管。根据描述（1）中“客户提交通用信息查询请求”，描述（2）中“医生提出应聘/辞职申请，交由主管进行聘用/解聘审批”、描述（3）中“医生安排出诊时间”、描述（5）中“根据主管提交的报表查询请求”和“生成报表返回给主管”等信息，对照图1-1中E1、E2和E3相关的数据流，即可确定E1为"客户“实体，E2为“医生”实体，E3为“主管”实体。

【问题2】（5分）使用说明中的词语，给出图1-2中的数据存储D1～D5的名称。
<img src="https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-1-2.png" style="zoom:80%;" />

- **D1：通用信息**，**D2：预约数据**，**D3：医生**，**D4：医生出诊时间**，**D5：药品**。（注：名称后面可以带有“文件”或“表”）
  本题要求确定图1-20层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明（1）中“查询通用信息表”，可知加工“通用信息查询”需要从存储D1中根据相关检索条件查询相关通用信息，由此可知D1为“通用信息”。说明（2）中“更新医生表...删除解聘医生的出诊安排”，可知加工“医生聘用”需要向D3更新医生列表，由此可知D3为“医生”。说明（3）中“存入医生出诊时间表”、“查询在职医生及其出诊时间等预约所需数据并返回”、“在预约表中新增预约记录”；可知加工“预约处理"向存储“医生出诊时间”新增出诊时间，向“预约数据“中新增预约，从“医生”表中查询在职医生相关信息。再对应图1-2中这几个数据存储所关联的数据流名称，可知D2为“预约数据”，D4为“医生出诊时间”。说明（4）中“根据药品名称从药品数据中查询相关药品库存信息，开出药品，更新对应药品的库存”，可知D5为“药品”。

【问题3】（4分）使用说明和图中术语，补充图1-2中缺失的数据流及其起点和终点。

- |       数据流       |      起点      |        终点        |
  | :----------------: | :------------: | :----------------: |
  |   更新的出诊时间   | P3 或 预约处理 | D4 或 医生出诊时间 |
  | 删除的医生出诊安排 | P2 或 医生聘用 | D4 或 医生出诊时间 |
  |    药品库存信息    |   D5 或 药品   |   P4 或 药品管理   |
  |      治疗信息      | P4 或 药品管理 |   D2 或 预约数据   |

  本题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，开未以少外部实体和加工之间的数据流。再考查题干中的说明判定图1-2中是否缺失内部的数据流，不难发现图中缺失的数据流，具体分析如下。
  根据说明（2）中“更新所约医生出诊时间并给医生发送预约通知"可知加工预约处理（P3）发给D4（医生出诊时间）的“更新的出诊时间”；根据说明（2）中“删除解聘医生的出诊安排”可知医生聘用（P2）向存储D4提交“删除的医生出诊安排”；根据说明（4）中“根据药品名称从药品数据中查询相关药品库存信息”可知药品管理（P4）从D5（药品）获取“药品库存信息”，并“更新对应药品的库存以及预约表中的治疗信息”，可知从P4向D2（预约数据）中更新“治疗信息”。预约处理分解为:安排出诊时间、预约查询、创建预约、预约反馈。图1-1（或父图）中某加工的输入输出数据流必须与图1-2（或子图）的输入输出数据流在数量和名字上相同；图1-1（或父图）中的一个输入（或输出）。数据流对应于图1-2（或子图）中几个输入（或输出）数据流，而图1-2（或子图）中组成这些数据流的数据项全体正好是父图中的这一条数据流。

【问题4】（3分）使用说明中的词语，说明“预约处理”可以分解为哪些子加工，并说明建模图1-1和图1-2是如何保持数据流图平衡。

- 在自顶向下建模分层DFD时，根据功能的粒度，可以进一步进行分解。在图1-2所示的0层数据流中，“预约处理”对应于说明（3），从中分析出需要执行的加工，进行分解，可以分为4个主要子加工一安排出诊时间、预约查询、创建预约、预约反馈。自顶向下进行建模时，需要保持数据流平衡，具体为父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流并集。

### 试题二（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】某海外代购公司为扩展公司业务，需要开发一个信息化管理系统。请根据公司现有业务及需求完成该系统的数据库设计。
【需求描述】
（1）记录公司员工信息。员工信息包括工号、身份证号、姓名、性别和一个手机号，工号唯一标识每位员工，员工分为代购员和配送员。
（2）记录采购的商品信息。商品信息包括商品名称、所在超市名称、采购价格、销售价格和商品介绍，系统内部用商品条码唯一标识每种商品。一种商品只在一家超市代购。
（3）记录顾客信息。顾客信息包括顾客真实姓名、身份证号（清关缴税用)、一个手机号和一个收货地址，系统自动生成唯一的顾客编号。
（4）记录托运公司信息。托运公司信息包括托运公司名称、电话和地址，系统自动生成唯一的托运公司编号。
（5）顾客登录系统之后，可以下订单购买商品。订单支付成功后，系统记录唯一的支付凭证编号，顾客需要在订单里指定运送方式:空运或海运。
（6）代购员根据顾客的订单在超市采购对应商品，一份订单所含的多个商品可能由多名代购员从不同超市采购。
（7）采购完的商品交由配送员根据顾客订单组合装箱，然后交给托运公司运送。托运公司按顾客订单核对商品名称和数量，然后按顾客的地址进行运送。
【概念模型设计】
根据需求阶段收集的信息，设计的实体联系图（不完整）如图2-1所示。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-2-1.png)

【逻辑结构设计】
根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）∶
员工（工号，身份证号，姓名，性别，手机号）
商品（条码，商品名称，所在超市名称，采购价格，销售价格，商品介绍）
顾客（编号，姓名，身份证号，手机号，收货地址）
托运公司（托运公司编号，托运公司名称，电话，地址）
订单（订单ID，（a），商品数量，运送方式，支付凭证编号）
代购（代购ID，代购员工号，（b））
运送（运送ID，配送员工号，托运公司编号，订单ID，发运时间）

【问题1】（3分）
根据问题描述，补充图2-1的实体联系图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-2-2.png)

- 本题考查数据库概念结构设计及向逻辑结构转换的应用。此类题目要求考生认真阅读题目，根据题目的需求描述，给出实体间的联系。根据题意由“采购完的商品交由配送员根据顾客订单组合装箱，然后交给托运公司运送。托运公司按顾客订单核对商品名称和数量，然后按顾客的地址进行运送"可知配送员、托运公司和订单三方参与运送联系，三方之间为`*:*:*`联系。

【问题2】（6分）补充逻辑结构设计结果中的（a）、（b）两处空缺。

- （a）**顾客编号，商品条码**
  （b）**订单ID，商品条码**
  根据需求描述（3）可知顾客信息包含收货地址，所以在顾客关系里应该包括“收货地址”。
  根据需求描述（2）和（6）可知顾客关系和商品关系是`*:*`联系，订单应该包含顾客所购商品的条码和数量，所以需要在订单关系模式中包含“商品数量”。根据需求描述（6）可知“根据顾客的订单在超市采购对应商品”，所以在代购关系里应该包括“商品条码”。

【问题3】（6分）为方便顾客，允许顾客在系统中保存多组收货地址。请根据此需求，增加“顾客地址”弱实体，对图2-1进行补充，并修改“运送”关系模式。

- 关系模式：运送（运送ID，配送员工号，托运公司编号，订单ID，顾客地址，发运时间）或者说明：增加属性“顾客地扯”。根据题意，由“允许顾客在系统中保存多组收货地址”，可知增加的“顾客地址”弱实体与顾客关系构成`*:1`联系。另外，增加了顾客地址后，运送的时候要选择顾客地址，所以运送关系模式中应增加"顾客地址"。配送员、托运公司、订单和顾客地址之间构成`*:*:*:*`联系。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-2-3.png) 

### 试题三（共15分）

阅读下列说明，回答问题1至问题3，将解答填入答题纸的对应栏内。
【说明】
某ETC（Electronic Toll Collection，不停车收费)系统在高速公路沿线的特定位置上设置一个横跨道路上空的龙门架（Toll gantry），龙门架下包括6条车道（Traffic lanes），每条车道上安装有雷达传感器（Radar sensor）、无线传输器（Radio transceiver）和数码相机（Digital Camera）等用于不停车收费的设备，以完成正常行驶速度下的收费工作。该系统的基本工作过程如下：
（1）每辆汽车上安装有车载器，驾驶员(Driver)将一张具有唯一识别码的磁卡插入车载器中。磁卡中还包含有驾驶员账户的当前信用记录。
（2）当汽车通过某条车道时，个停牛收费仅面次别车载器内的特有编码，判断车型，将收集到的相关信息发送到该路段所属的区域系统（Regional center）中，计算通行费用，创建收费交易（Transaction），从驾驶员的专用账户中扣除通行费用。如果驾驶员账户透支，则记录透支账户交易信息。区域系统再将交易后的账户信息发送到维护驾驶员账户信息的中心系统（Central system）。
（3）车载器中的磁卡可以使用邮局的付款机进行充值。充值信息会传送至中心系统，以更新驾驶员账户的余额。
（4）当没有安装车载器或者车载器发生故障的车辆通过车道时，车道上的数码相机将对车辆进行拍照，并将车辆照片及拍摄时间发送到区域系统，记录失败的交易信息；并将该交易信息发送到中心系统。
（5）区域系统会获取不停车收费设备所记录的交通事件（Traffic events）；交通广播电台（Traffic advice center）根据这些交通事件进行路况分析并播报路况。
现采用面向对象方法对上述系统进行分析与设计，得到如表3-1所示的用例列表以及如图3–1所示的用例图和图3–2所示的分析类图。

![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-3.png)
![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-3-1.png)

【问题1】（4分）根据说明中的描述，给出图3-1中A1～A4所对应的参与者名称。

- **A1：Driver**
  **A2：Central system**
  **A3：Traffic advice center**
  **A4：Regional center**

  本题主要考查面向对象分析与设计的基本概念及应用。在建模方面，本题涉及了UML的用例图和类图，考查的模式是根据需求说明将模型补充完整。题目难度不大，属于经典考题。这两个问题都是针对图3-1所示的用例图，分别补充图中缺失的参与者和用例。
  在UML用例图中，参与者（actor）表示要与本系统发生交互的一个角色单元（人或其他系统）。用例（usecase）表示由本系统提供的一个业务功能单元。题目中已经给出了用例列表，可以根据这些用例在需求描述中寻找相关的参与者。
  表3-1中给出了5个用例。经过简单的分析，可以把这5个用例分成三类：①Create transaction、Underpaid transaction、Record Illegal use。这三个用例都跟通行收费相关，这也暗示着这个用例之间必定是有关联关系的。②Charge card，这个用例与通行收费有着间接关联，因为磁卡中记录了驾驶员账户的信用记录。③Record traffic event，这是个独立于收费的用例。所以可以把用例“记录交通事件”作为解题的突破点。对于“Record traffic event”用例，说明中的第（5）条：“区域系统会获取不停车收费设备所记录的交通事件（Traffic events）；交通广播电台（Traffic advice center）根据这些交通事件进行路况分析并播报路况。"由此可以看出，在这个用例中，区域系统做的是写操作记读交通事件；交通广播电台（ Traffic advice center）做的是读操作一路况分析。所以区域系统、交通广播电台这个用例的两个参与者。同时，也可以跟3-1所示的用例图对号入座了。从图中可以看出A3、A4和U4组成了一个相对独立的子用列图。根据前文的分析，可以确定U4对应的就是用例“Record traffic event”，A3和A4分别对应着参与者“区域系统”和”交通广播电台“。”Charge card“用例，说明中的第（3）条：“车载器中的磁卡可以使用邮局的付款机进行充值”。虽然这里没有明确的说明充值的主语，但是磁卡的拥有者是驾驶员，因此可以推断出，用例“磁卡充值”的参句者就是驾驶员。现在可以与用例图进行对应，根据前文分析可以看出，U5对应着“Charge card”。另外充值信息会传送至中心系统，所以“charge card”用例还有另外一个参与者，就是中心系统。现在4个参与者已经全部识别出来：驾驶员、中心系统、区域系统和交通广播电台。区域系统和交通广播电台已经对应A3和A4。目前需要确定的是A1和A2以及U1～U3的对应关系。

【问题2】（5分）据说明中的描述及表3-1，给出图3-1中J1～U5所对应的用例名称。

- **U1：Underpaid transaction**
  **U2：Record illegal use**
  **U3：Create transaction**
  **U4：Record traffic event**
  **U5：Charge card**
  其中U1、U2可以互换，用例名称必须为英文，因为表中的汉字是对用例的说明。从图3-1中可以看出，U3和U1、U2之间是extend（扩展关系）。扩展关系是对基础用例的扩展，基础用例是一个完整的用例，即使没有扩展用例的参与，也可以完成一个完整的功能。基础用例提供了—组扩展点，在这些新的扩展点中可以添加新的行为，而扩展用例提供了一组片段，这些片段能够被插入到基本用例的扩展点上。一般情况下，基础用例的执行不会涉及扩展用例，只有扩展点被激活时，扩展用例才会执行。因此扩展关系通常用来描述事件流的异常或者可选事件。用例“Create transaction”、“Underpaid transaction”和“Record illegal use”中，“Underpaid
  transaction”和“Record illegal use”是正常事件流中的特殊情况，可以作为扩展用例。这样就可以确定出，U3对应着用例“Create transaction”U1和U2分别对应着用例“Underpaid transaction”和“Record illegal use”A1和A2分别对应着参与者驾驶员和中心系统。

【问题3】（6分）根据说明中的描述，给出图3–2中C1～C6所对应的类名。

- **C1：Center system**
  **C2：Toll gantry**
  **C3：Traffic lanes**
  **C4：Radar sensor**
  **C5：Radio transceiver**
  **C6：Digital Camera**
  其中C4、C5、C6可以互换。本问题要求将图3-2中的类补充完成。解答此类题目时应先观察和分析类图，特别要注意类图中出现的一些特殊关系，如继承、聚集、组装等，以及关系的多重度。在图3-2中出现了多个组装关系。组装表达的是一种“部分—整体”关系，在使用组装关系时，区分清楚哪个类代表整体，哪个类代表部分。由图3-2可见，C2和C3的聚集关系的多重度为“6”。在说明中“龙门架下包括6条车道（Traffic lanes）”，也就是说这6条车道是龙门架的一个组成部分，所以可以初步推断C2对应着龙门架（Toll gantry）、C3对应着车道（Traffic lanes）。再看说明中:“每条车道上安装有雷达传感器（Radar sensor），无线传输器（Radio transceiver）和数码相机（Digital Camera）等用于不停车收费的设备，即雷达传感器（Radar sensor）、无线传输器（Radio
  transceiver）和数码相机 （Digital Camera）与车道之间构成了“部分-整体”关系，符合图中C3与C4与C6之间的关系。由此可以完全确定C3为车道（Traffic lanes）。C4与C6分别对应着雷达传感器（Radar sensor）、无线传输器（Radio transceiver）和数码相机 （Digital Camera）。最后来确定C1，由与C1有关联关系的类”Regional Center"可以得出，C1应该对应着Central system。根据在补充用例图时对需求的深入分析，也可以确定这一点: Central system和Regional Center共同完成通行收费的行为。

### 试题四（共15分）

阅读下列说明和C代码，回答问题1和问题2，将解答填入答题纸的对应栏内。
【说明】
某公司购买长钢条，将其切割后进行出售。切割钢条的成本可以忽略不计，钢条的长度为整英寸。已知价格表p，其中$p_i$（i=1, 2, ..., m）表示长度为`i`英寸的钢条的价格。现要求解使销售收益最大的切割方案。求解此切割方案的算法基本思想如下：
假设长钢条的长度为`n`英寸，最佳切割方案的最左边切割段长度为`i`英寸，则继续求解剩余长度为n-i英寸钢条的最佳切割方案。考虑所有可能的i，得到的最大收益r,对应的切割方案即为最佳切割方案。$r_n$的递归定义如下：$r_n=max_{1<i≤n}(P_i+r_{n-i})$。对此递归式，给出自顶向下和自底向上两种实现方式。

【C代码】

```c
/*常量和变量说明
  n:长钢条的长度
  p[]:价格数组
*/
#define LEN 100

int Top_Down_Cut_Rod(int p[], int n) {  /*自项向下*/
    int r = 0;
    int i;
    if (n == 0) {
        return 0;
    }
    for(i = 1; __(1)__; i++) {
        int tmp = p[i] +Top_Down_Cut_Rod(p, n - i);
        r = (r >= tmp) ? r : tmp;
    }
    return r;
}

int Bottom_Up_cut_Rod(int p[], int n) {  /*自底向上*/
    int r[LEN] = {0};
    int temp = 0;
    int i，j;
    for(j = 1; j <= n; j++) {
        temp = 0;
        for(i = 1; __(2)__; i++) {
            temp = __(3)__;
        }
        __(4)__;
    }
    return r[n];
}
```

【问题1】（8分）根据说明，填充C代码中的空（1）～（4）。

- （1）**`i<=n`**
  （2）**`i<=j`**
  （3）**`temp>=p[i]+r[j-i])?temp:p[i]+r[j-i]`** 或其等效形式
  （4）**`r[j]=temp`**
  本题考查算法设计与分析技术的基础知识和应用能力。解答该类题目，首先需要理解问题和求解问题的算法思想，一般在题干中已经清晰地描述了算法的基本思想。钢条切割问题是一个最优化问题。求解的思路非常简单，考虑最优方案中最左边的切割，此时将一个大问题转化为一个小问题。题干已经给出了最关键的递归式。C程序根据递归式，给出自顶向下和自底向上两种实现方法。
  在自顶向下的实现中，直接用递归方法实现递归式，因此空（1）填`i<=n`。在自底向上的实现中，采用迭代方法实现递归式，这里采用了两重循环。外重循环j表示问题的规模，内重循环计算规模为j的钢条切割的最优解的值，因此空（2）填`i<=j`。空（3）其实就是算法的核心，判断当前的最优解对应的价值`temp`大，还是当前的`i`对应的最优解的价值`p[i]+r[j-i]`更大，如果temp小，则更换当前最优解对应的价值。因此，空（3）填入`if(temp<p[i]+r[j-i]) {temp=p[i]+r[j-i]}`，也可以参考自顶向下的实现方法中的语句`r=(r>=tmp)?r:tmp`，答案为`temp>=p[i]+r[j-i] ? temp : p[i]+r[j-i]`。对某个`j`计算得到其最优解后，将其存到`r[j]`中，即空（4）填`r[j]=temp`。

【问题2】（7分）根据说明和C代码，算法采用的设计策略为（5）。求解$r_n$时，自顶向下方法的时间复杂度为（6）；自底向上方法的时间复杂度为（7）（用O表示）。

- （5）**动态规划法**
  （6）$O(2^n)$
  （7）$O(n^2)$
  根据题干说明和C程序，应该比较清晰看出算法是基于动态规划策略设计的。在自顶向下的实现中，因为是递归实现，可以列出递归式如下：$T(n)=1+\sum_{i=0}^{n-1}T(i)$。求解该式，得到时间复杂度为$O(2^n)$。那么高的时间复杂度主要是因为相同的子问题会多次重复的被调用。若不会求解该式，可以画出递归树求解。而在自底向上的实现方法中采用了两重循环，因此算法的时间复杂度为$O(n^2)$。

### 试题五（共15分）

阅读下列说明和C++代码，将应填入（n）处的字句写在答题纸的对应栏内。
【说明】
生成器（Builder）模式的意图是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。图5-1所示为其类图。![](https://img.tanyaodan.com/%E8%BD%AF%E8%80%83/2018s-5-1.png)

【C++代码】

```c++
class Product {
private:
    string partA, partB,
public:
    Product() { }
    void setPartA(const string s) { partA = s; }
    void setPartB(const string s) { partB = s; }
    //其余代码省略
};

class Builder {
public:
    __(1)__;
    virtual void buildPartB()=0:
    __(2)__;
};

class ConcreteBuilder1 : public Builder {
private:
    Product* product;
public:
    ConcreteBuilder1() {product = new Product(); }
    void buildPartA() { __(3)__ ("Component A"); }
    void buildPartB() { __(4)__ ("Component B"); }
    Product* getResut() { return product; }
    // 其余代码省略
};

class ConcreteBuilder2 : public Builder {
/* 代码省略 */
};

class Director {
private:
    Builder* builder;
public:
    Director(Builder* pBuilder) { builder= pBuilder; }
    void construct() {
        __(5)__;
        // 其余代码省略
    }
    // 其余代码省略
};

int main() {
    Director* director1 = new Director(new ConcreteBuilder1());
    director1->construct();
    delete director1;
    return 0;
}
```

【问题1】（15分）填充C++代码中的空（1）～（5）。

- （1）**`virtual void buildPartA()=0`**
  （2）**`virtual Product * getResult()=0`**
  （3）**`product->setPartA`**
  （4）**`product->setPartB`**
  （5）**`builder->buildPartA()`** 或 **`builder->buildPartB();`**

  本题考查设计模式中生成器（Builder）模式的基本概念和实现。生成器模式是一种典型的创建型模式。创建型模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。在这些模式中有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些具体的类的信息封装起来。第二，它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定），也可以是动态的（在运行时）。生成器模式的意图是，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的标识。生成器模式的结构如图5-2所示。其中：
  `Builder`为创建一个`Product`对象的各个部件制定抽象接口。
  `ConcreteBuilder`的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。
  `Director`构造一个使用`Builder`接口的对象。
  `Product`表示被构造的复杂对象。`ConcreteBuilder`创建该产品的内部表示并定义它的装配过程，包含定义组成组件的类，包括将这些组件装配成最终产品的接口。
  生成器模式适用于：当创建复杂对象的算法应该独立与该对象的组成部分以及它们的装配方式时；当构造过程必须允许被构造的对象有不同的表示时。
  图5-1中的类`Product`包含两个组成部分：`partA`和`partB`，因此在类Builder中需要为这两个组成部分创建抽象接口。在C++中，抽象接口通常采用纯虚拟函数来实现。纯虚拟函数是没有实现体的虚拟函数，它在基类中定义，在派生类中重置。构造`partB`的接口在代码中已经给出，因此第（1）空应填写**`virtual void buildPartA() = 0`**。
  第（2）空可以从`Builder`的派生类`ConcreteBuilder1`来进行推断，在`ConcreteBuilder1`中出现方法`getResult`，根据上下文，可以判定该方法可能继承自其基类`Builder`，并在派生类中重置。因此第（2）空填**`virtual Product * getResult() = 0`**。
  第（3）空和第（4）空用于创建产品的内部表示。`Product`包含两部分`partA`和`partB`，分别调用类`Product`中提供的方法`setPartA`和`setPartB`来实现。因此，第（3）空和第（4）空空分别填入**`product->setPartA`** 和 **`product->setPartB`**。
  第（5）空是对`Bulider`中接口的使用，这里应填入**`builder->buildPartA()`**或**`builder->buildPartB()`**。

------

